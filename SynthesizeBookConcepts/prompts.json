{
  "instruction_prompt": "You are an expert in Python programming and instructional design. Given the concepts and examples below, generate six distinct instructions with complexity level: {difficulty}. Ensure the tasks are as non-overlapping as possible while covering diverse aspects of the concepts.\n\nCOMPLEXITY GUIDELINES:\n1. This {difficulty} difficulty should create {complexity_description}.\n2. Solutions should span approximately {expected_lines} of code with rich, intricate logic maximized for 'hard' tasks.\n\nINSTRUCTIONS FOR PROBLEM DIVERSITY:\n1. Create problems that are fundamentally different in:\n   - Problem domain: Include mathematics (e.g., algebra for equations and transformations, timing & durations for scheduling or sequencing, probabilities for statistical analysis, geometry for spatial computations), finance, data processing, algorithms, text processing, or system design. For 'hard' tasks, prioritize complex mathematical domains to ensure challenging synthesis.\n   - Computational approach: Vary between iterative, recursive, dynamic programming, functional, or object-oriented programming.\n   - Algorithmic complexity: Target specific time complexities (e.g., O(n) for easy, O(n log n) for medium, O(n²) or higher for hard) appropriate to the difficulty, ensuring 'hard' tasks demand significant computational depth.\n2. Before generating, analyze the concept's core principles and identify unique problem-solving strategies that leverage these principles, especially for mathematical domains in 'hard' tasks to maximize complexity and clarity.\n3. Instructions may request either a standalone function named 'solution' or a class named 'Solution' with methods; indicate clearly if a class is required (e.g., 'implement a class') and specify the primary method name (e.g., 'compute') if applicable, otherwise assume 'compute' as the default primary method for classes.\n\nConcept:\n{concept}\n\nDescription:\n{description}\n\nExamples:\n{examples}\n\nInstructions should contain only the instruction text. Generate your response in the following format:\nInstruction1:\n{{}}\n\nInstruction2:\n{{}}\n\nInstruction3:\n{{}}\n\nInstruction4:\n{{}}\n\nInstruction5:\n{{}}\n\nInstruction6:\n{{}}",
  "signature_prompt": "You are a Python programming expert. Given the instruction below, analyze how it should be implemented and provide the best signature skeleton. Follow these STRICT rules to determine the implementation type and format the output:\n1. Decide if the instruction requires a standalone function or a class:\n   - Choose a CLASS if the instruction EXPLICITLY says 'implement a class', 'create a class', or mentions methods like 'constructor', 'build_tree', etc., using the specified class name (e.g., 'HuffmanTree').\n   - Otherwise, default to a standalone FUNCTION named 'solution'.\n2. For a FUNCTION:\n   - Format EXACTLY as: 'Function: name(param1: type1, param2: type2) -> return_type'\n   - Include parameter names, types (infer if not specified), and return type (use 'unknown' if unclear).\n3. For a CLASS:\n   - Format EXACTLY as: 'Class: ClassName; __init__(self, param1: type1) -> return_type; method1(self, param2: type2) -> return_type; ...'\n   - Use semicolons (;) to separate class name and methods.\n   - Include '__init__' with parameters if implied, followed by all required methods.\n   - Specify the primary method (named in instruction or 'compute' if unspecified) for testing.\n   - Use 'unknown' for return types if not inferable.\n4. RULES FOR FORMATTING:\n   - Use ONLY spaces (no tabs, newlines, or escaped characters like '\\').\n   - Use EXACTLY the syntax shown (e.g., '__init__', '->', commas between params).\n   - Do NOT add extra punctuation (e.g., colons after parentheses) or quotes around simple types (e.g., use 'Matrix', not '\"Matrix\"').\n   - Do NOT deviate from the template—any variation is invalid.\n   - Do NOT include explanations, prose, or multiple class definitions in one block—provide ONLY ONE signature skeleton.\n   - Ensure the response is complete (no truncation) and matches the template EXACTLY.\n5. Base your analysis ONLY on the instruction text, inferring types and outputs logically.\nInstruction:\n{instruction}\n\nReturn the signature skeleton INSIDE a code block, following the EXACT format below:\n```text\nFunction: solution(input1: type1, input2: type2) -> return_type\n```\nor\n```text\nClass: ClassName; __init__(self, param1: type1) -> return_type; method1(self, param2: type2) -> return_type\n```\n\nExamples of CORRECT output:\n```text\nFunction: solution(freq_list: list[tuple[str, int]]) -> dict[str, str]\n```\n```text\nClass: HuffmanTree; __init__(self, freq_list: list[tuple[str, int]]) -> unknown; build_tree(self) -> tuple; get_encoding(self) -> dict[str, str]\n```\nExamples of INCORRECT output (DO NOT USE):\n```text\nClass: Matrix; **init**(self, data: list[list[int]]): add(self, other: \"Matrix\") -> \"Matrix\"\n```\n```text\nClass: Polynomial; \\ __init__(self, coeffs: list[float]) -> None; \\ evaluate(self, value: float) -> float\n```\n```text\nClass: Shape; area(self) -> float; Class: Circle; __init__(self, radius: float) -> None\n```\nOutput MUST match the correct examples EXACTLY in format.",
  "code_prompt_function": "You are a Python programming expert. Given the instruction and signature details below, generate 5 functionally correct Python code adhering to these constraints:\n1. **HIGH PRIORITY**: Implement a standalone function with name '{function_name}', inputs '{input_params}', and return type '{return_type}' EXACTLY as provided. Do NOT deviate from this signature.\n2. Write all logic directly within '{function_name}'—do NOT define nested functions, even for multi-step problems; use variables or steps instead.\n3. The function MUST ALWAYS RETURN A VALUE matching '{return_type}'.\n4. Ensure the code is fully modular, self-contained, and does not rely on external code or global variables.\n5. Optimize for readability, following Python best practices, with clear variable names and comments where necessary.\n6. For hard difficulty, ensure the solution reflects the expected complexity: sophisticated long problems requiring complex algorithms and data structures (8-10 difficulty), spanning approximately 50-100+ lines with a difficulty score of 8-10 on a scale of 1-10.\n7. **HIGH PRIORITY**: Generate EXACTLY FIVE distinct implementations, all strictly adhering to the provided signature:\n   - Vary each implementation by:\n     - Computational approach: Use distinct methods like iterative loops, recursion, dynamic programming, list comprehensions, or functional programming (e.g., map/filter/reduce), as appropriate to the instruction and difficulty.\n     - Style: Alternate between verbose, step-by-step logic and concise, optimized solutions; use different commenting styles (e.g., inline vs. block comments).\n     - Variable names: Use unique, meaningful names for variables and parameters in each response.\n     - Complexity: Within the hard level, explore simpler vs. more intricate implementations (e.g., brute force vs. optimized algorithms).\n   - Analyze the instruction to identify multiple viable strategies before generating solutions.\n   - **ENSURE COMPLETENESS**: Each of the five implementations MUST be fully functional, including all required logic as specified in the instruction. Do NOT provide incomplete code (e.g., missing logic); generate all five implementations in full before terminating the response.\nInstruction:\n{instruction}\n\nSignature Details:\n- Function Name: {function_name}\n- Inputs: {input_params}\n- Return Type: {return_type}\n\nGenerate EXACTLY FIVE Python code blocks, all adhering to the provided signature, in this format:\n```python\ndef {function_name}():  # Use the specified function name\n    # Write the solution logic directly here (no nested functions)\n    # Return the final output (MANDATORY)\n    return ...  # Replace with actual value\n```",
  "code_prompt_class": "You are a Python programming expert. Given the instruction and signature details below, generate 5 functionally correct Python code implementations adhering to these constraints:\n1. HIGH PRIORITY: Implement a class with name '{class_name}' and methods as specified in '{method_signatures}' (including inputs and return types) EXACTLY as provided. Do NOT deviate from these signature details.\n2. Include a constructor '{constructor_signature}' ONLY if explicitly provided in the signature details or if the instruction requires initialization of instance variables for the class to function correctly. Otherwise, omit the constructor.\n3. Define the class with all necessary methods as specified, avoiding a function template.\n4. Each method must be self-contained; each method MUST RETURN A VALUE matching its specified return type.\n5. Ensure the code is fully modular, self-contained, and does not rely on external code or global variables.\n6. Optimize for readability, following Python best practices, with clear variable names and comments where necessary.\n7. For hard difficulty, ensure the solution reflects the expected complexity: sophisticated long problems requiring complex algorithms and data structures (8-10 difficulty), spanning approximately 50-100+ lines with a difficulty score of 8-10 on a scale of 1-10.\n8. HIGH PRIORITY: Generate EXACTLY FIVE distinct implementations, all strictly adhering to the provided signature details:\n   - Vary each implementation by:\n     - Computational approach: Use distinct methods like iterative loops, recursion, dynamic programming, list comprehensions, or functional programming (e.g., map/filter/reduce), as appropriate to the instruction and difficulty.\n     - Style: Alternate between verbose, step-by-step logic and concise, optimized solutions; use different commenting styles (e.g., inline vs. block comments).\n     - Variable names: Use unique, meaningful names for variables and parameters in each response.\n     - Complexity: Within the hard level, explore simpler vs. more intricate implementations (e.g., brute force vs. optimized algorithms).\n   - Analyze the instruction to identify multiple viable strategies before generating solutions.\n   - ENSURE COMPLETENESS: Each of the five implementations MUST be fully functional, including all required methods or logic as specified in the instruction. Do NOT provide incomplete code (e.g., missing method bodies or logic); generate all five implementations in full before terminating the response.\nInstruction:\n{instruction}\n\nSignature Details:\n- Class Name: {class_name}\n- Constructor: {constructor_signature}\n- Methods: {method_signatures}\n\nGenerate EXACTLY FIVE Python code blocks, all adhering to the provided signature details. Use this format when a constructor is needed:\n```python\nclass {class_name}:  # Use the specified class name\n    def __init__(self, freq_list):  # Constructor with specified parameters, only if required\n        # Initialize attributes here\n        pass\n    def build_tree(self):  # Specified method\n        # Construct the Huffman tree\n        return ...  # Return as required\n    def get_encoding(self):  # Specified method\n        # Return the encoding dictionary (MANDATORY)\n        return ...  # Replace with actual value\n```\nIf no constructor is required, use this simpler format:\n```python\nclass {class_name}:  # Use the specified class name\n    def build_tree(self):  # Specified method\n        # Construct the Huffman tree\n        return ...  # Return as required\n    def get_encoding(self):  # Specified method\n        # Return the encoding dictionary (MANDATORY)\n        return ...  # Replace with actual value\n```",
  "test_prompt_function": "You are an expert in Python testing and requirements analysis. Generate up to 10 isolated test cases for the following programming task based on the task description and the provided list of required test scenarios. Follow these CRITICAL GUIDELINES:\n1. Each test case must be a standalone Python function (e.g., `def test_...():`), NOT defined within a class, to ensure easy parsing and execution.\n2. Each test function must contain EXACTLY ONE assert statement.\n3. Every assert statement MUST DIRECTLY call the function with specific inputs and compare its result to an expected value using a direct comparison (e.g., `==`, `is`, `in`, `!=`):\n   - The solution to the task is a standalone function named '{function_name}', use `assert {function_name}(...) == ...` with all inputs packed into the call.\n   - Do NOT:\n     - Use variables or initializations outside the assert (e.g., `x = [1, 2]; assert {function_name}(x) == ...`).\n     - Do NOT Use try-except blocks or check exceptions indirectly (e.g., `assert str(e) == ...`).\n     - Do NOT use vague assertions (e.g., `assert == True`).\n     - Use indirect comparisons (e.g., `.equals(...)`, timing checks).\n     - Rely on external values; pack all necessary logic into the assert statement.\n4. Generate up to 10 test cases, each corresponding to one of the required test scenarios provided below, ensuring each test directly calls the function with inputs matching the signature, all within the assert. If fewer than 10 scenarios are provided, generate only that number.\n5. Verify that each test aligns with the task requirements, signature details, and the specified test scenario; all inputs must match the provided signature.\n6. Ensure every assert statement is complete, specifying a concrete expected output value (e.g., a number, list, or string) and avoiding placeholders (e.g., '...'). Calculate the exact expected result based on the task description and signature for each test case.\nTask Description:\n{instruction}\n\nSignature Details:\n```python\n{function_signature}\n```\n\nRequired Test Scenarios:\n{required_tests}\n\nUse the template based on the signature (examples show dos and don’ts):\n```python\n# Do this:\ndef test_basic_functionality():\n    # Test basic scenario\n    assert {function_name}([1, 2, 3], 2) == 42\n\n# Don't do this:\ndef test_basic_functionality_wrong():\n    # Incorrect: variable outside assert\n    lst = [1, 2, 3]\n    assert {function_name}(lst, 2) == 42\n\n# Don't do this:\ndef test_multi_assert_case():\n    # Test scenario with multiple independent checks (not preferred)\n    # Test Case 1\n    assert {function_name}([1, 2], 1) == 10\n    # Test Case 2\n    assert {function_name}([3, 4], 1) == 20\n```",
  "test_prompt_class": "You are an expert in Python testing and requirements analysis. Generate up to 10 isolated test cases for the following programming task based solely on the task description and the provided list of required test scenarios, without seeing the implementation. Follow these CRITICAL GUIDELINES:\n1. Each test case must be a standalone Python function (e.g., `def test_...():`), NOT defined within a class, to ensure easy parsing and execution.\n2. Each test function must contain EXACTLY ONE assert statement, unless the solution is a class with multiple methods and multiple asserts are needed to call logically connected methods (e.g., setup methods) before the primary method; in such cases, separate each assert with a numbered comment like `# Test Case 1`, `# Test Case 2`, etc., to distinguish them. For connected methods, prefer chaining them within a single assert statement (e.g., `{class_name}().setup(...).{primary_method}(...) == ...`) unless multiple asserts are unavoidable.\n3. Every assert statement MUST DIRECTLY call the connected methods with specific inputs and compare its result to an expected value using a direct comparison (e.g., `==`, `is`, `in`, `!=`):\n   - The solution to the task is a class named '{class_name}'. The primary method to test is '{primary_method}'. Instantiate it as `{class_name}()` and call methods directly in the assert; for logically connected methods, chain them within one assert (e.g., `assert {class_name}().method1(...).method2(...) == ...`). Do NOT:\n     - Use variables or class instantiations outside the assert (e.g., `c = {class_name}(); assert c.method1(...).method2(...) == ...`).\n     - Use try-except blocks or check exceptions indirectly (e.g., `assert str(e) == ...`).\n     - Use vague assertions (e.g., `assert == True`).\n     - Use indirect comparisons (e.g., `.equals(...)`, timing checks).\n     - Rely on external values; pack all logic into the assert statement.\n4. Generate up to 10 test cases, each corresponding to one of the required test scenarios provided below, ensuring each test directly calls the relevant method(s) with inputs matching their signature, all within the assert. If fewer than 10 scenarios are provided, generate only that number.\n5. Verify that each test aligns with the task requirements, signature details, and the specified test scenario; all inputs must match the method signatures.\n6. Ensure every assert statement is complete, specifying a concrete expected output value (e.g., a number, list, or string) and avoiding placeholders (e.g., '...'). Calculate the exact expected result based on the task description and signature for each test case.\nTask Description:\n{instruction}\n\nSignature Details:\n```python\nClass: {class_name}\nClass Methods:\n{method_signatures}\nPrimary Method: {primary_method}\n```\n\nRequired Test Scenarios:\n{required_tests}\n\nGenerate test cases in this format, with each test in its own standalone function, using ONLY direct calls in asserts with complete expected values, packing all logic into the assert. Use the template based on the signature (examples show dos and don’ts):\n- For class-based solutions:\n```python\n# Do this:\ndef test_basic_functionality():\n    # Test basic scenario\n    assert {class_name}().{primary_method}([1, 2, 3]) == 42\n\n# Do this for logically connected methods, ensuring instantiation and calls are in one assert:\ndef test_connected_methods():\n    # Test scenario where object instantiation and connected method calls are all in one assert statement\n    assert {class_name}().setup([1, 2]).{primary_method}(3) == 42\n\n# Don't do this:\ndef test_basic_functionality_wrong():\n    # Incorrect: multiple asserts for class without logical connection\n    assert {class_name}().{primary_method}([1, 2]) == 10\n    assert {class_name}().{primary_method}([3, 4]) == 20\n\n# Don't do this:\ndef test_setup_wrong():\n    # Incorrect: setup outside assert\n    obj = {class_name}()\n    obj.setup([1, 2])\n    assert obj.{primary_method}(3) == 42\n```",
  "identify_tests_prompt": "You are an expert in Python testing and requirements analysis. Given the instruction and signature details below, analyze the task and identify a list of up to 10 concise test scenarios to guide test case generation. Each scenario must be a short hint (e.g., 'Test basic addition', 'Test empty input') to ensure all methods and key behaviors are tested, avoiding excessive detail. Focus on:\n- Basic functionality of each method or function in the signature.\n- Key behaviors or operations from the instruction.\n- Broad coverage of the task’s intent.\nReturn the list in this EXACT format, with no extra text outside the text block:\n```text\nTest scenario 1\nTest scenario 2\n...\n```\nTask Description:\n{instruction}\n\nSignature Details:\n{signature_details}"
  }

