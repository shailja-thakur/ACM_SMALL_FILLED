% --- Custom Color Definitions for Appendix ---
\definecolor{promptblue}{RGB}{0, 102, 204}
\definecolor{darkgray}{RGB}{64, 64, 64}
\definecolor{commentgreen}{RGB}{0, 128, 0}
\definecolor{keywordblue}{RGB}{0, 0, 255}
\definecolor{stringred}{RGB}{163, 21, 21}
\definecolor{highlightyellow}{RGB}{255, 255, 204}

% --- Listings Syntax Highlighting Style ---
\lstdefinestyle{python-custom}{
    language=Python,
    basicstyle=\ttfamily\scriptsize,
    keywordstyle=\color{keywordblue},
    stringstyle=\color{stringred},
    commentstyle=\color{commentgreen},
    morecomment=[l]{\#},
    frame=tb, % Top and bottom frame lines
    framerule=0.5pt,
    numbers=none,
    breaklines=true,
    showstringspaces=false,
}

\newcounter{appendixfigure}
\renewcommand{\theappendixfigure}{A.\arabic{appendixfigure}}

\section*{Appendix: Verifiable CoT Data Samples}
This appendix provides concrete examples of the verifiable Chain-of-Thought (CoT) data generated by our synthesis pipeline. The samples are organized to showcase the diversity of our dataset across two key dimensions: \textbf{reasoning direction} and \textbf{problem difficulty}. We include examples for:
\begin{itemize}[nosep, leftmargin=*]
    \item \textbf{Reasoning Direction:} Forward-only, Backward-only, and Bi-directional conversational formats.
    \item \textbf{Problem Difficulty:} Samples rated at levels 2 (Easy), 3 (Medium), and 4 (Hard) based on our quality-scoring mechanism.
\end{itemize}
Each sample is presented in a structured format that distinguishes the user prompt (the problem context) from the model's generated response (the verifiable reasoning and final answer).




% \begin{figure}[h!]
% \caption{Forward-only CoT Sample (Difficulty: 2 - Easy)}
% \label{lst:fwd-easy-sample}
% \begin{tcolorbox}[
%     enhanced, breakable,
%     fontupper=\ttfamily\scriptsize,
%     colback=white, colframe=darkgray,
%     boxrule=0.8pt, arc=3pt,
%     boxsep=0pt,
%     left=6pt, right=6pt, top=1pt, bottom=4pt,
%     toptitle=2pt, bottomtitle=2pt,
%     title={\ttfamily\scriptsize\textbf{Sample: Forward Reasoning (Difficulty 2)}},
%     coltitle=white, colbacktitle=darkgray
% ]
% % --- User Prompt Section ---
% \begin{tcolorbox}[enhanced, colback=blue!5!white, boxsep=2pt, arc=2pt, boxrule=0.5pt, colframe=blue!20!white]
% \textbf{\color{blue!60!black}User Prompt (Forward)}
% \begin{lstlisting}[language=python, frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}]
% The `solution` function takes a list of events with associated probabilities, normalizes the probabilities if they do not sum to 1, and returns the cumulative distribution function (CDF) and the probability density function (PDF) by sorting the events and computing the CDF through accumulation.
% Here's the code:
% ```python
% from functools import reduce

% def solution(events: list[tuple[str, float]]) -> tuple[list[float], list[float]]:
%     # Sort events by probability
%     sorted_events = sorted(events, key=lambda x: x)
    
%     # Extract probabilities
%     probabilities = list(map(lambda x: x, sorted_events))
    
%     # Normalize probabilities if they don't sum to 1
%     total_prob = reduce(lambda acc, x: acc + x, probabilities, 0)
%     probabilities = list(map(lambda p: p / total_prob, probabilities)) if total_prob != 1 else probabilities
    
%     # Calculate PDF
%     pdf = probabilities
    
%     # Calculate CDF
%     cdf = []
%     cumulative_prob = 0
%     for prob in pdf:
%         cumulative_prob += prob
%         cdf.append(cumulative_prob)
    
%     return cdf, pdf
% ```
% What output does the function return when given the input [('a', 0.5), ('b', 0.5)]?
% \end{lstlisting}
% \end{tcolorbox}

% \vspace{4pt}

% % --- Model Response Section ---
% \begin{tcolorbox}[enhanced, colback=ForestGreen!5!white, boxsep=2pt, arc=2pt, boxrule=0.5pt, colframe=ForestGreen!20!white]
% \textbf{\color{ForestGreen!60!black}Assistant Response }
% \begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
% ### Understand
% The goal is to determine the output of the function `solution` when given the input `events = [('a', 0.5), ('b', 0.5)]`. The function's purpose is to compute two lists: the probability density function (PDF) and the cumulative distribution function (CDF) of the input probabilities. The function sorts the events by their probabilities, extracts the probabilities, normalizes them if necessary, and then calculates the PDF and CDF.

% Key components:
% - Sorting the events by probability.
% - Extracting probabilities and normalizing them if they don't sum to 1.
% - Calculating the PDF (normalized probabilities).
% - Calculating the CDF by accumulating the probabilities.

% ### Plan
% To determine the output, I will:
% 1. Analyze the input and the initial operations (sorting and extracting probabilities).
% 2. Check if normalization is needed and perform it if necessary.
% 3. Calculate the PDF using the normalized probabilities.
% 4. Calculate the CDF by accumulating the PDF values.
% 5. Verify the final output by considering the logical flow and ensuring all steps are consistent.

% ### Execute
% 1. **Input and Sorting**: The input is `events = [('a', 0.5), ('b', 0.5)]`. The sorting step sorts the events by the second element (probability), but since both probabilities are equal, the order remains `('a', 0.5), ('b', 0.5)`.
% 2. **Extracting Probabilities**: The probabilities extracted are `[0.5, 0.5]`.
% 3. **Normalization Check**: The sum of probabilities is `0.5 + 0.5 = 1.0`. Since the total is already 1, no normalization is needed, and the probabilities remain `[0.5, 0.5]`.
% 4. **PDF Calculation**: The PDF is directly the list of probabilities, `[0.5, 0.5]`.
% 5. **CDF Calculation**:
%    - Initialize `cumulative_prob = 0`.
%    - For the first probability `0.5`, `cumulative_prob = 0 + 0.5 = 0.5`. Append `0.5` to `cdf`.
%    - For the second probability `0.5`, `cumulative_prob = 0.5 + 0.5 = 1.0`. Append `1.0` to `cdf`.
%    - The resulting CDF is `[0.5, 1.0]`.
% 6. **Final Output**: The function returns the tuple `(cdf, pdf)`, which is `([0.5, 1.0], [0.5, 0.5])`.

% ### Reflect
% The reasoning process involved analyzing each step of the function, ensuring that the probabilities were correctly extracted, checked for normalization, and used to compute the PDF and CDF. The calculations were straightforward, and the logic of accumulating probabilities for the CDF was correctly applied. The final output aligns with the expected behavior of the function, confirming that the reasoning was thorough and accurate.
% Predicted Output: ([0.5, 1.0], [0.5, 0.5])
% \end{lstlisting}
% \end{tcolorbox}
% \end{tcolorbox}
% \end{figure}




\clearpage
\onecolumn


% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Forward Reasoning (Difficulty 2)}
\label{lst:fwd-easy-sample} % You can still label and ref this subsection

% --- User Prompt Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Forward)}
\vspace{2pt}

The `solution` function takes a list of events with associated probabilities, normalizes them if they do not sum to 1, and returns the cumulative distribution function (CDF) and the probability density function (PDF).
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
from functools import reduce

def solution(events: list[tuple[str, float]]) -> tuple[list[float], list[float]]:
    # Sort events by probability
    sorted_events = sorted(events, key=lambda x: x[1])
    
    # Extract probabilities
    probabilities = list(map(lambda x: x[1], sorted_events))
    
    # Normalize if necessary
    total_prob = sum(probabilities)
    if total_prob != 1:
        probabilities = [p / total_prob for p in probabilities]
    
    # Calculate PDF
    pdf = probabilities
    
    # Calculate CDF
    cdf = []
    cumulative_prob = 0
    for prob in pdf:
        cumulative_prob += prob
        cdf.append(cumulative_prob)
    
    return cdf, pdf
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What output does the function return when given the input [('a', 0.5), ('b', 0.5)]?
}}
\end{tcolorbox}

% A natural paragraph break (a blank line in the code) allows for a page break.

% --- Model Response Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine the output of the function `solution` when given the input `events = [('a', 0.5), ('b', 0.5)]`. The function's purpose is to compute two lists: the probability density function (PDF) and the cumulative distribution function (CDF) of the input probabilities. The function sorts the events by their probabilities, extracts the probabilities, normalizes them if necessary, and then calculates the PDF and CDF.

Key components:
- Sorting the events by probability.
- Extracting probabilities and normalizing them if they don't sum to 1.
- Calculating the PDF (normalized probabilities).
- Calculating the CDF by accumulating the probabilities.

### Plan
To determine the output, I will:
1. Analyze the input and the initial operations (sorting and extracting probabilities).
2. Check if normalization is needed and perform it if necessary.
3. Calculate the PDF using the normalized probabilities.
4. Calculate the CDF by accumulating the PDF values.
5. Verify the final output by considering the logical flow and ensuring all steps are consistent.

### Execute
1. **Input and Sorting**: The input is `events = [('a', 0.5), ('b', 0.5)]`. The sorting step sorts the events by the second element (probability), but since both probabilities are equal, the order remains `('a', 0.5), ('b', 0.5)`.
2. **Extracting Probabilities**: The probabilities extracted are `[0.5, 0.5]`.
3. **Normalization Check**: The sum of probabilities is `0.5 + 0.5 = 1.0`. Since the total is already 1, no normalization is needed, and the probabilities remain `[0.5, 0.5]`.
4. **PDF Calculation**: The PDF is directly the list of probabilities, `[0.5, 0.5]`.
5. **CDF Calculation**:
   - Initialize `cumulative_prob = 0`.
   - For the first probability `0.5`, `cumulative_prob = 0 + 0.5 = 0.5`. Append `0.5` to `cdf`.
   - For the second probability `0.5`, `cumulative_prob = 0.5 + 0.5 = 1.0`. Append `1.0` to `cdf`.
   - The resulting CDF is `[0.5, 1.0]`.
6. **Final Output**: The function returns the tuple `(cdf, pdf)`, which is `([0.5, 1.0], [0.5, 0.5])`.

### Reflect
The reasoning process involved analyzing each step of the function, ensuring that the probabilities were correctly extracted, checked for normalization, and used to compute the PDF and CDF. The calculations were straightforward, and the logic of accumulating probabilities for the CDF was correctly applied. The final output aligns with the expected behavior of the function, confirming that the reasoning was thorough and accurate.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Output: ([0.5, 1.0], [0.5, 0.5])
}}
\end{tcolorbox}





\clearpage
\onecolumn



% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Forward Reasoning (Difficulty 3)}
\label{lst:fwd-medium-sample} % You can still label and ref this subsection

% --- User Prompt Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Forward)}
\vspace{2pt}

The `solution` function approximates a solution to the Traveling Salesman Problem by using a greedy algorithm to find a route that visits all given locations exactly once, prioritizing closer locations (within 10 units) to the current location, and returns to the starting point.
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
def solution(locations):
    from math import sqrt

    def distance(p1, p2):
        return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

    if len(locations) < 2:
        return locations

    # Start from the first location
    start = locations[0]
    remaining = locations[1:]
    route = [start]

    while remaining:
        # Calculate distances from the current location
        current = route[-1]
        # Prioritize locations within 10 units using ternary operation
        prioritized = sorted(
            remaining,
            key=lambda loc: (distance(current, loc) <= 10, distance(current, loc))
        )
        # Select the closest location
        next_location = prioritized[0]
        route.append(next_location)
        remaining.remove(next_location)

    # Return to the starting point
    route.append(start)
    return route
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What does the function return when given the input [(0, 0), (1, 1), (2, 2), (3, 3)]?
}}
\end{tcolorbox}

% A natural paragraph break (a blank line in the code) allows for a page break.

% --- Model Response Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine the output of the `solution` function when given the input `[(0, 0), (1, 1), (2, 2), (3, 3)]`. The function is designed to construct a route from a list of locations, starting from the first location, and then iteratively selecting the next location based on proximity, prioritizing those within 10 units. The function returns to the starting point after visiting all other locations. Key components include the `distance` function, the sorting mechanism for prioritizing locations, and the loop that builds the route.

### Plan
1. **Initialization**: Understand the initial setup of variables like `start`, `remaining`, and `route`.
2. **Loop Execution**: Analyze the loop's behavior, focusing on how it selects the next location based on distance and prioritization.
3. **Return to Start**: Consider the final step where the route returns to the starting point.
4. **Verify**: Ensure the reasoning aligns with the expected behavior of the function.

### Execute
1. **Initialization**:
   - The function begins by checking if there are fewer than two locations, in which case it returns the input as is. This is not applicable here since there are four locations.
   - `start` is set to the first location `(0, 0)`.
   - `remaining` is initialized with the rest of the locations `[(1, 1), (2, 2), (3, 3)]`.
   - `route` starts with `[start]`, i.e., `[(0, 0)]`.

2. **Loop Execution**:
   - The loop continues as long as there are locations in `remaining`.
   - For each iteration, the current location is the last in `route`.
   - The `remaining` locations are sorted based on whether they are within 10 units and then by distance.
   - The closest location is selected and added to `route`, then removed from `remaining`.

   **Iteration Details**:
   - **First Iteration**:
     - `current` is `(0, 0)`.
     - Distances to remaining locations: 
       - `(1, 1)`: \(\sqrt{2}\)
       - `(2, 2)`: \(\sqrt{8}\)
       - `(3, 3)`: \(\sqrt{18}\)
     - All are within 10 units, so they are sorted by distance: `[(1, 1), (2, 2), (3, 3)]`.
     - `next_location` is `(1, 1)`, added to `route`, and removed from `remaining`.

   - **Second Iteration**:
     - `current` is `(1, 1)`.
     - Distances to remaining locations:
       - `(2, 2)`: \(\sqrt{2}\)
       - `(3, 3)`: \(\sqrt{8}\)
     - Both are within 10 units, sorted by distance: `[(2, 2), (3, 3)]`.
     - `next_location` is `(2, 2)`, added to `route`, and removed from `remaining`.

   - **Third Iteration**:
     - `current` is `(2, 2)`.
     - Distance to remaining location `(3, 3)` is \(\sqrt{2}\).
     - `next_location` is `(3, 3)`, added to `route`, and removed from `remaining`.

3. **Return to Start**:
   - After the loop, the route returns to the starting point `(0, 0)` by appending it to `route`.

4. **Final Route**:
   - The constructed route is `[(0, 0), (1, 1), (2, 2), (3, 3), (0, 0)]`.

### Reflect
The reasoning process aligns with the function's logic, ensuring that each step is consistent with the code's behavior. The function correctly constructs a route based on proximity and returns to the start, confirming the expected output. The approach considered the sorting mechanism and loop behavior, ensuring a thorough understanding of the function's execution. The final output is consistent with the expected behavior and the trace provided.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Output: [(0, 0), (1, 1), (2, 2), (3, 3), (0, 0)]
}}
\end{tcolorbox}







\clearpage
\onecolumn


% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Forward Reasoning (Difficulty 4)}
\label{lst:fwd-hard-sample-divide-conquer} % You can still label and ref this subsection

% --- User Prompt Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Forward)}
\vspace{2pt}

The `solution` function identifies the pair of tuples with the smallest Euclidean distance from a sorted list of coordinate tuples using a divide-and-conquer approach, ensuring efficient performance with a time complexity of O(n log n).
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
def solution(coordinates):
    # Helper function to calculate Euclidean distance
    def euclidean_distance(point1, point2):
        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5

    # Recursive function to find the closest pair
    def closest_pair(coords):
        if len(coords) <= 3:
            return brute_force(coords)

        mid = len(coords) // 2
        left_half = coords[:mid]
        right_half = coords[mid:]

        # Find closest pairs in each half
        left_closest = closest_pair(left_half)
        right_closest = closest_pair(right_half)

        # Determine the smaller distance
        min_distance = min(euclidean_distance(*left_closest), euclidean_distance(*right_closest))
        closest_pair = left_closest if euclidean_distance(*left_closest) < euclidean_distance(*right_closest) else right_closest

        # Check the strip around the midpoint
        strip = [point for point in coords if abs(point[0] - coords[mid][0]) < min_distance]
        strip.sort(key=lambda x: x[1])  # Sort strip by y-coordinate

        for i in range(len(strip)):
            for j in range(i + 1, len(strip)):
                if (strip[j][1] - strip[i][1]) >= min_distance:
                    break
                distance = euclidean_distance(strip[i], strip[j])
                if distance < min_distance:
                    min_distance = distance
                    closest_pair = (strip[i], strip[j])

        return closest_pair

    # Brute force approach for small number of points
    def brute_force(points):
        min_distance = float('inf')
        closest = None
        for i in range(len(points)):
            for j in range(i + 1, len(points)):
                distance = euclidean_distance(points[i], points[j])
                if distance < min_distance:
                    min_distance = distance
                    closest = (points[i], points[j])
        return closest

    # Sort coordinates by x-coordinate
    sorted_coords = sorted(coordinates, key=lambda x: x[0])
    return closest_pair(sorted_coords)
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What output does the `solution` function return when given the input `[(1, 2), (3, 4)]`?
}}
\end{tcolorbox}

% A natural paragraph break (a blank line in the code) allows for a page break.

% --- Model Response Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The `solution` function is designed to find the closest pair of points from a list of 2D coordinates using Euclidean distance. The function employs a recursive approach to solve this problem efficiently, leveraging a divide-and-conquer strategy. The key components of the function include:

1. **Euclidean Distance Calculation**: A helper function `euclidean_distance` computes the distance between two points.
2. **Recursive Closest Pair Function**: The `closest_pair` function recursively divides the list of points and finds the closest pair in each half. It also considers points near the dividing line to ensure the closest pair is found.
3. **Brute Force Method**: For small subsets of points (3 or fewer), the `brute_force` function is used to find the closest pair by checking all possible pairs.
4. **Sorting**: The input coordinates are sorted by their x-coordinates before processing.

The function's goal is to return the pair of points with the smallest Euclidean distance.

### Plan
To determine the output for the input `[(1, 2), (3, 4)]`, we will:

1. **Analyze Initialization**: Understand how the input is processed initially, particularly the sorting step.
2. **Trace Recursive Logic**: Follow the recursive logic of `closest_pair` to see how it handles the input.
3. **Evaluate Base Case**: Since the input has only two points, the base case of the recursion will be reached quickly.
4. **Compute Distances**: Calculate the Euclidean distance between the two points to verify the result.
5. **Consider Edge Cases**: Although not directly applicable here, consider if the logic holds for minimal inputs.

### Execute
1. **Initialization**: The input `[(1, 2), (3, 4)]` is sorted by x-coordinates, resulting in `sorted_coords = [(1, 2), (3, 4)]`.
2. **Recursive Logic**:
   - The `closest_pair` function is called with `sorted_coords`.
   - Since the length of `coords` is 2, the function does not split further and directly proceeds to the `brute_force` function.
3. **Base Case Evaluation**:
   - In `brute_force`, the function iterates over all pairs of points.
   - For `[(1, 2), (3, 4)]`, there is only one pair to consider: `(1, 2)` and `(3, 4)`.
4. **Distance Calculation**:
   - Compute the Euclidean distance between `(1, 2)` and `(3, 4)`:
     \[
     \text{distance} = \sqrt{(3 - 1)^2 + (4 - 2)^2} = \sqrt{4 + 4} = \sqrt{8} = 2\sqrt{2}
     \]
   - Since this is the only pair, it is the closest pair by default.
5. **Return Result**:
   - The function returns the pair `((1, 2), (3, 4))` as the closest pair.

### Reflect
The reasoning aligns with the function's logic, as the input size is small enough to directly use the brute force method. The calculation of the Euclidean distance confirms that the pair `(1, 2)` and `(3, 4)` is indeed the closest pair. The function's design ensures that even with minimal inputs, the correct pair is returned. The approach is robust and generalizes well to larger inputs by using the divide-and-conquer strategy.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Output: ((1, 2), (3, 4))
}}
\end{tcolorbox}




\clearpage
\onecolumn

% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Forward Reasoning (Difficulty 4)}
\label{lst:fwd-hard-sample} % You can still label and ref this subsection

% --- User Prompt Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Forward)}
\vspace{2pt}

The `solution` function calculates the probability of an event occurring across a sequence of independent trials using binary partitioning and the inclusion-exclusion principle, efficiently handling up to 1,000 trials with memoization to ensure high precision.
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
def solution(probabilities):
    # Helper function to calculate the combined probability using inclusion-exclusion
    def combine_probs(p1, p2):
        return p1 + p2 - (p1 * p2)

    # Recursive approach with memoization to avoid redundant calculations
    memo = {}

    def recursive_prob(start, end):
        if (start, end) in memo:
            return memo[(start, end)]
        if end - start == 1:
            return probabilities[start]
        mid = (start + end) // 2
        prob_left = recursive_prob(start, mid)
        prob_right = recursive_prob(mid, end)
        combined = combine_probs(prob_left, prob_right)
        memo[(start, end)] = combined
        return combined

    return recursive_prob(0, len(probabilities))
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
When I pass a list of probabilities to the `solution` function, does it return a combined probability of 1.0, considering it uses the inclusion-exclusion principle to calculate the probability?
}}
\end{tcolorbox}

% A natural paragraph break (a blank line in the code) allows for a page break.

% --- Model Response Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The `solution` function is designed to compute a combined probability from a list of individual probabilities using the inclusion-exclusion principle. The function includes a helper function `combine_probs` that combines two probabilities using the formula \( p1 + p2 - (p1 \times p2) \). The main function uses a recursive approach with memoization to efficiently calculate the combined probability for the entire list. The recursion splits the list into halves until it reaches base cases of single probabilities, then combines them back up using the `combine_probs` function. The memoization helps avoid redundant calculations by storing results of subproblems.

### Plan
To determine if the function returns a combined probability of 1.0, we need to:
1. Understand how the inclusion-exclusion principle is applied through the `combine_probs` function.
2. Analyze the recursive structure and how it processes the list of probabilities.
3. Consider edge cases, such as when the list contains probabilities that sum to 1 or when probabilities are 0 or 1.
4. Verify if the recursive combination of probabilities can logically result in 1.0.

### Execute
1. **Inclusion-Exclusion Principle**: The `combine_probs` function combines two probabilities \( p1 \) and \( p2 \) using the formula \( p1 + p2 - (p1 \times p2) \). This formula accounts for the overlap between two events, ensuring that the combined probability does not exceed 1.
2. **Recursive Structure**: The function `recursive_prob` divides the list into smaller segments, computes the combined probability for each segment, and then combines these results. The base case is when the segment contains a single probability, which is returned directly.
3. **Edge Cases**:
   - If all probabilities are 0, the combined probability will be 0.
   - If all probabilities are 1, the combined probability will be 1.
   - If the list contains a mix of 0s and 1s, the result will depend on their arrangement and combination.
4. **Logical Combination to 1.0**: For the function to return 1.0, the combination of probabilities must account for all possible overlaps such that the final result is 1.0. This can happen if the probabilities are structured such that their combined effect covers the entire probability space.
5. **Mathematical Consideration**: The inclusion-exclusion principle ensures that as more probabilities are combined, the overlap is subtracted, preventing the result from exceeding 1.0. Given enough probabilities and their overlaps, it is possible for the combined probability to reach 1.0, especially if the probabilities are structured to cover all possible outcomes.

### Reflect
The function's logic, using the inclusion-exclusion principle and recursive combination, can indeed result in a combined probability of 1.0, particularly if the input probabilities are structured to cover the entire probability space. The recursive approach with memoization ensures efficient computation, and the inclusion-exclusion principle prevents the result from exceeding 1.0. The trace confirms that the function returns 1.0 for the given input, aligning with the logical deduction.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Output: True
}}
\end{tcolorbox}




\clearpage
\onecolumn

% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Forward Reasoning (Difficulty 4)}
\label{lst:fwd-hard-sample-dp} % You can still label and ref this subsection

% --- User Prompt Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Forward)}
\vspace{2pt}

The function schedules tasks by sorting them by deadline and using dynamic programming to determine the minimum start time for each task, then reconstructs and returns the schedule with task details including start times.
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
def solution(tasks):
    # Sort tasks by their deadline
    tasks.sort(key=lambda x: x[2])
    n = len(tasks)
    # Initialize a DP table to store the minimum start time for each task
    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    # Fill the DP table
    for i in range(1, n + 1):
        task_name, duration, deadline = tasks[i - 1]
        for j in range(i + 1):
            # If we don't take the current task
            dp[i][j] = dp[i - 1][j]
            # If we take the current task
            if j > 0:
                start_time = max(dp[i - 1][j - 1], deadline - duration)
                dp[i][j] = min(dp[i][j], start_time + duration)

    # Reconstruct the solution
    result = []
    time = dp[n][n]
    for i in range(n, 0, -1):
        if dp[i][n] != dp[i - 1][n]:
            task_name, duration, deadline = tasks[i - 1]
            start_time = max(dp[i - 1][n - 1], deadline - duration)
            result.append((task_name, duration, deadline, start_time))
            time = start_time
            n -= 1

    return result[::-1]
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
When I provide the input `[("task1", 0, 0), ("task2", 2147483647, 2147483647)]` to the `solution` function, will it return `[('task1', 0, 0, 0), ('task2', 2147483647, 2147483647, 0)]` as expected?
}}
\end{tcolorbox}

% A natural paragraph break (a blank line in the code) allows for a page break.

% --- Model Response Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine if the `solution` function, when given the input `[("task1", 0, 0), ("task2", 2147483647, 2147483647)]`, will return `[('task1', 0, 0, 0), ('task2', 2147483647, 2147483647, 0)]`. The function appears to be solving a scheduling problem using dynamic programming (DP). It sorts tasks by their deadlines and calculates the earliest possible start time for each task, ensuring no task starts after its deadline. The DP table `dp` is used to store the minimum start time for scheduling a subset of tasks. The function then reconstructs the schedule to provide the start time for each task.

### Plan
1. **Initialization and Sorting**: Verify that the tasks are sorted by their deadlines.
2. **DP Table Setup**: Understand the initialization of the DP table and its purpose.
3. **DP Table Filling**: Analyze how the DP table is filled, focusing on the logic for deciding whether to include a task and calculating the start time.
4. **Reconstruction**: Examine how the solution is reconstructed from the DP table.
5. **Validation**: Check if the reconstructed solution matches the expected output.

### Execute
1. **Initialization and Sorting**:
   - The input tasks are sorted by their deadlines: `[("task1", 0, 0), ("task2", 2147483647, 2147483647)]`. Since "task1" has an earlier deadline, the order remains unchanged.
2. **DP Table Setup**:
   - A DP table `dp` of size `(n+1) x (n+1)` is initialized with `inf`, except `dp[0][0] = 0`. This setup is for storing the minimum start time for scheduling `j` tasks out of the first `i` tasks.
3. **DP Table Filling**:
   - For each task, the table is filled considering two scenarios: including the task or not.
   - **Task 1 ("task1", 0, 0)**:
     - For `j = 0`: `dp[1][0] = dp[0][0] = 0`.
     - For `j = 1`: Calculate `start_time = max(dp[0][0], 0 - 0) = 0`. Update `dp[1][1] = min(inf, 0 + 0) = 0`.
   - **Task 2 ("task2", 2147483647, 2147483647)**:
     - For `j = 0`: `dp[2][0] = dp[1][0] = 0`.
     - For `j = 1`: Calculate `start_time = max(dp[1][0], 2147483647 - 2147483647) = 0`. Update `dp[2][1] = min(0, 0 + 2147483647) = 0`.
     - For `j = 2`: Calculate `start_time = max(dp[1][1], 2147483647 - 2147483647) = 0`. Update `dp[2][2] = min(inf, 0 + 2147483647) = 2147483647`.
4. **Reconstruction**:
   - Start from the last task and check if including it changes the DP value.
   - For `i = 2` ("task2"): `dp[2][2] != dp[1][2]`, so include it. Calculate `start_time = max(dp[1][1], 2147483647 - 2147483647) = 0`. Add `('task2', 2147483647, 2147483647, 0)`.
   - Update `time = 0`, `n = 1`.
   - For `i = 1` ("task1"): `dp[1][1] != dp[0][1]`, so include it. Calculate `start_time = max(dp[0][0], 0 - 0) = 0`. Add `('task1', 0, 0, 0)`.
5. **Validation**:
   - The reconstructed result is `[('task2', 2147483647, 2147483647, 0), ('task1', 0, 0, 0)]`.
   - Reverse it to get `[('task1', 0, 0, 0), ('task2', 2147483647, 2147483647, 0)]`, which matches the expected output.

### Reflect
The reasoning process involved understanding the DP approach used for scheduling tasks and verifying each step of the logic. The reconstruction step was crucial in ensuring the output matched the expected result. The chosen method was robust, as it considered both the DP table filling and the reconstruction process. The final output aligns with the expected result, confirming the correctness of the function's logic.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Output: [('task1', 0, 0, 0), ('task2', 2147483647, 2147483647, 0)]
}}
\end{tcolorbox}








\clearpage
\onecolumn





% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Backward Reasoning (Difficulty 4)}
\label{lst:bwd-hard-sample} % You can still label and ref this subsection

% --- User Prompt Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Backward)}
\vspace{2pt}

The function `solution` calculates and returns the mean, median, and mode of a non-empty list of integers, ensuring input validity through assertions.
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
def solution(numbers: list[int]) -> dict[str, float]:
    # Assertions to ensure valid input
    assert numbers, "Input list cannot be empty."
    assert all(isinstance(item, int) for item in numbers), "List must contain only integers."

    # Mean calculation
    total = sum(numbers)
    length = len(numbers)
    mean_result = total / length

    # Median calculation
    sorted_nums = sorted(numbers)
    half = length // 2
    if length % 2 == 0:
        median_result = (sorted_nums[half - 1] + sorted_nums[half]) / 2
    else:
        median_result = sorted_nums[half]

    # Mode calculation using a dictionary to count occurrences
    count_dict = {}
    for num in numbers:
        count_dict[num] = count_dict.get(num, 0) + 1
    max_count = max(count_dict.values())
    mode_result = min(key for key, value in count_dict.items() if value == max_count)

    # Return the computed statistics
    return {'mean': mean_result, 'median': median_result, 'mode': float(mode_result)}
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What input would produce the output {'mean': 2.0, 'median': 2, 'mode': 1} when passed to the function?
}}
\end{tcolorbox}

% A natural paragraph break (a blank line in the code) allows for a page break.

% --- Model Response Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to deduce the input(s) that produce the output `{'mean': 2.0, 'median': 2, 'mode': 1}` when passed to the `solution` function. The function calculates three statistical measures: mean, median, and mode from a list of integers. The mean is the average of the numbers, the median is the middle value when sorted, and the mode is the most frequent number (with ties broken by the smallest number). The function includes assertions to ensure the input is a non-empty list of integers.

### Plan
To deduce the input(s), I will reverse engineer the calculations for mean, median, and mode:

1. **Mean**: The mean is calculated as the sum of the numbers divided by the count. For a mean of 2.0, the sum of the numbers divided by their count must equal 2.0.
2. **Median**: The median is the middle value in a sorted list. For a median of 2, the middle value (or average of two middle values) must be 2.
3. **Mode**: The mode is the most frequent number. For a mode of 1, the number 1 must appear more frequently than any other number.

I will explore different list configurations that satisfy these conditions, considering both odd and even lengths of the list. I will also ensure that the mode condition is met by having 1 as the most frequent number.

### Execute
1. **Mean Calculation**:
   - Let the list be `[a1, a2, ..., an]`.
   - The mean condition is: \((a1 + a2 + ... + an) / n = 2.0\).
   - Therefore, \(a1 + a2 + ... + an = 2n\).

2. **Median Calculation**:
   - For an odd-length list, the median is the middle element.
   - For an even-length list, the median is the average of the two middle elements.
   - The median must be 2.

3. **Mode Calculation**:
   - The number 1 must appear more frequently than any other number.

**Case 1: Odd-length list (n = 3)**
- Mean: \(a1 + a2 + a3 = 6\).
- Median: The middle element must be 2.
- Mode: 1 must appear more frequently than any other number.

Possible list: `[1, 2, 3]`
- Sum: \(1 + 2 + 3 = 6\), Mean: \(6/3 = 2.0\).
- Sorted: `[1, 2, 3]`, Median: 2.
- Mode: All numbers appear once, but 1 is the smallest, so mode is 1.

**Case 2: Even-length list (n = 4)**
- Mean: \(a1 + a2 + a3 + a4 = 8\).
- Median: The average of the two middle elements must be 2.
- Mode: 1 must appear more frequently than any other number.

Possible list: `[1, 1, 2, 4]`
- Sum: \(1 + 1 + 2 + 4 = 8\), Mean: \(8/4 = 2.0\).
- Sorted: `[1, 1, 2, 4]`, Median: \((1 + 2)/2 = 1.5\) (not valid).

**Case 3: Odd-length list (n = 5)**
- Mean: \(a1 + a2 + a3 + a4 + a5 = 10\).
- Median: The middle element must be 2.
- Mode: 1 must appear more frequently than any other number.

Possible list: `[1, 1, 2, 3, 3]`
- Sum: \(1 + 1 + 2 + 3 + 3 = 10\), Mean: \(10/5 = 2.0\).
- Sorted: `[1, 1, 2, 3, 3]`, Median: 2.
- Mode: 1 appears twice, 3 appears twice, but 1 is the smallest, so mode is 1.

### Reflect
The deduced inputs that satisfy the conditions are `[1, 2, 3]` and `[1, 1, 2, 3, 3]`. Both produce the desired output. The given input `[1, 2, 3]` matches one of the deduced inputs, confirming the correctness of the deduction. The approach was exhaustive, considering both odd and even lengths, and ensuring all conditions for mean, median, and mode were met.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Input: Plausible input 1: [1, 2, 3]
Plausible input 2: [1, 1, 2, 3, 3]
}}
\end{tcolorbox}




\clearpage
\onecolumn



% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Backward Reasoning (Difficulty 4)}
\label{lst:bwd-hard-sample-matrix} % You can still label and ref this subsection

% --- User Prompt Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Backward)}
\vspace{2pt}

The `invert\_matrix` method in the `MatrixOperations` class calculates and returns the inverse of a given square matrix (up to 3x3), ensuring the matrix is square and non-singular with assert statements.
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
class MatrixOperations:
    def invert_matrix(self, matrix: list[list[float]]) -> list[list[float]]:
        n = len(matrix)
        assert all(len(row) == n for row in matrix), "Matrix must be square"
        
        det = self._recursive_determinant(matrix)
        assert det != 0, "Matrix is singular and cannot be inverted"
        
        cofactors = [[self._cofactor(matrix, i, j) for j in range(n)] for i in range(n)]
        adjugate = [[cofactors[j][i] for j in range(n)] for i in range(n)]
        inverse = [[adjugate[i][j] / det for j in range(n)] for i in range(n)]
        
        return inverse

    def _recursive_determinant(self, matrix: list[list[float]]) -> float:
        n = len(matrix)
        if n == 1:
            return matrix[0][0]
        if n == 2:
            return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]
        det = 0
        for c in range(n):
            det += ((-1) ** c) * matrix[0][c] * self._recursive_determinant(self._minor(matrix, 0, c))
        return det

    def _minor(self, matrix: list[list[float]], i: int, j: int) -> list[list[float]]:
        return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])]

    def _cofactor(self, matrix: list[list[float]], i: int, j: int) -> float:
        minor = self._minor(matrix, i, j)
        return ((-1) ** (i + j)) * self._recursive_determinant(minor)
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What input matrix would produce the inverse `[[0.6, -0.7], [-0.2, 0.4]]` when passed to the `invert\_matrix` function?
}}
\end{tcolorbox}

% A natural paragraph break (a blank line in the code) allows for a page break.

% --- Model Response Section ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine the input matrix that, when passed to the `invert_matrix` function, produces the inverse matrix `[[0.6, -0.7], [-0.2, 0.4]]`. The function inverts a given square matrix using the method of cofactors, adjugate, and determinant. The key operations include calculating the determinant, cofactors, and adjugate, followed by dividing the adjugate by the determinant to get the inverse.

### Plan
1. **Reverse the Inverse Calculation**: Start by understanding the relationship between the input matrix and its inverse. The inverse matrix is calculated as `adjugate / det`. Therefore, the input matrix can be found by reversing this process.
2. **Mathematical Rigor**: Use the formula for the inverse of a 2x2 matrix:
   \[
   \text{If } A = \begin{bmatrix} a & b \\ c & d \end{bmatrix}, \text{ then } A^{-1} = \frac{1}{ad-bc} \begin{bmatrix} d & -b \\ -c & a \end{bmatrix}
   \]
   Given the inverse, set up equations to solve for the original matrix elements.
3. **Multiple Approaches**: 
   - **Direct Calculation**: Use the inverse matrix to directly calculate the original matrix using the properties of 2x2 matrices.
   - **Verification**: Verify the solution by recalculating the inverse from the deduced input matrix.
4. **Address Ambiguities**: Ensure that the determinant is non-zero and that the matrix is square.

### Execute
1. **Reverse the Inverse Calculation**:
   - Given inverse matrix: \(\begin{bmatrix} 0.6 & -0.7 \\ -0.2 & 0.4 \end{bmatrix}\)
   - Let the original matrix be \(\begin{bmatrix} a & b \\ c & d \end{bmatrix}\).
   - The inverse is calculated as:
     \[
     \begin{bmatrix} 0.6 & -0.7 \\ -0.2 & 0.4 \end{bmatrix} = \frac{1}{ad-bc} \begin{bmatrix} d & -b \\ -c & a \end{bmatrix}
     \]
   - Equating elements:
     \[
     0.6 = \frac{d}{ad-bc}, \quad -0.7 = \frac{-b}{ad-bc}, \quad -0.2 = \frac{-c}{ad-bc}, \quad 0.4 = \frac{a}{ad-bc}
     \]
2. **Solve for Original Matrix Elements**:
   - Let \(k = ad-bc\). Then: \(d = 0.6k, \quad a = 0.4k, \quad b = 0.7k, \quad c = 0.2k\).
   - Substitute into \(ad-bc = k\):
     \[
     (0.4k)(0.6k) - (0.7k)(0.2k) = k
     \]
     \[
     0.10k^2 = k \implies k(0.10k - 1) = 0
     \]
   - Since \(k \neq 0\), \(0.10k = 1 \implies k = 10\).
3. **Calculate Original Matrix**:
   - Substitute \(k = 10\): \(a=4, b=7, c=2, d=6\).
   - Original matrix: \(\begin{bmatrix} 4 & 7 \\ 2 & 6 \end{bmatrix}\)
4. **Verification**:
   - Calculate the determinant: \(4 \times 6 - 7 \times 2 = 10\).
   - Calculate the inverse: \(\begin{bmatrix} 6 & -7 \\ -2 & 4 \end{bmatrix} / 10 = \begin{bmatrix} 0.6 & -0.7 \\ -0.2 & 0.4 \end{bmatrix}\).
   - The calculated inverse matches the given inverse, confirming the solution.

### Reflect
The deduced input matrix \(\begin{bmatrix} 4 & 7 \\ 2 & 6 \end{bmatrix}\) is verified to produce the given inverse matrix. The reasoning process involved reversing the inverse calculation and solving for the original matrix elements using the properties of 2x2 matrices. The approach was exhaustive, considering the mathematical properties and verifying the solution. The solution is optimal and comprehensive, as it aligns with the function's logic and the given output.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Input: Plausible input: [[4, 7], [2, 6]]
}}
\end{tcolorbox}



\clearpage
\onecolumn


% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Bi-Directional Conversation (Difficulty 4)}
\label{lst:bidirectional-hard-sample} % You can still label and ref this subsection

% --- User Prompt Section (Forward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Forward)}
\vspace{2pt}

The `solution` function sorts a list of DNA sequences by their GC-content in descending order, using lexicographical order as a tiebreaker, and includes error handling for invalid DNA sequences containing characters other than 'A', 'T', 'C', 'G'.
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
def solution(dna_sequences):
    # Calculate GC-content using list comprehension
    def gc_content(seq):
        return (seq.count('G') + seq.count('C')) / len(seq)

    # Validate sequences and prepare for sorting
    valid_sequences = [
        (gc_content(seq), seq) for seq in dna_sequences
        if all(nucleotide in 'ATCG' for nucleotide in seq)
    ]

    # Raise error if any invalid sequence is found
    if len(valid_sequences) != len(dna_sequences):
        raise ValueError("Invalid DNA sequence detected.")

    # Sort sequences by GC-content and lexicographically
    valid_sequences.sort(key=lambda x: (-x[0], x[1]))

    # Return sorted sequences
    return [seq for _, seq in valid_sequences]
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
When we pass a list of DNA sequences where each sequence is composed of a varying number of 'G's followed by 'A's, does the function return the sequences sorted by their GC-content from lowest to highest?
}}
\end{tcolorbox}

% --- Model Response Section (Forward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The task is to determine if the given Python function `solution` sorts a list of DNA sequences by their GC-content from lowest to highest. Each sequence is composed of a varying number of 'G's followed by 'A's. The function calculates the GC-content for each sequence, validates the sequences, and sorts them based on GC-content and lexicographically. Key components include the `gc_content` function, the validation of sequences, and the sorting mechanism.

### Plan
1. **Analyze the `gc_content` function**: Understand how it calculates the GC-content for a sequence.
2. **Examine sequence validation**: Ensure all sequences are valid DNA sequences.
3. **Understand the sorting logic**: Determine how sequences are sorted by GC-content and lexicographically.
4. **Evaluate the overall effect**: Assess if the function sorts sequences from lowest to highest GC-content.
5. **Consider edge cases**: Check if sequences with the same GC-content are handled correctly.

### Execute
1. **GC-content Calculation**:
   - The `gc_content` function calculates the GC-content as the ratio of 'G's and 'C's to the total length of the sequence. Since sequences only contain 'G's and 'A's, 'C's are absent, and the GC-content is simply the proportion of 'G's.
2. **Sequence Validation**:
   - The function checks if each sequence contains only 'A', 'T', 'C', and 'G'. Given the problem constraints, all sequences are valid.
3. **Sorting Logic**:
   - The sequences are sorted using `valid_sequences.sort(key=lambda x: (-x[0], x[1]))`. This sorts primarily by GC-content in descending order (`-x[0]`) and secondarily by lexicographical order (`x[1]`).
4. **Effect of Sorting**:
   - The sorting order is from highest to lowest GC-content due to the negative sign in `-x[0]`. This means sequences with more 'G's (higher GC-content) appear first.
5. **Edge Cases**:
   - If sequences have the same GC-content, they are sorted lexicographically. Since 'G' < 'A', sequences with more 'G's will appear first among those with the same GC-content.

### Reflect
The function does not sort sequences from lowest to highest GC-content; it sorts them from highest to lowest. The use of `-x[0]` in the sorting key indicates descending order. This conclusion aligns with the function's logic and the observed behavior in the execution trace. The reasoning process considered the function's structure, calculations, and sorting mechanism, ensuring a thorough understanding.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Output: No, the function returns the sequences sorted by their GC-content from highest to lowest.
}}
\end{tcolorbox}

% --- User Prompt Section (Backward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Backward)}
\vspace{2pt}\\
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What kind of input list would result in the function returning a list of DNA sequences sorted from those with 0% GC-content to those with 100% GC-content?
}}
\end{tcolorbox}

% --- Model Response Section (Backward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine what kind of input list would cause the function `solution` to return a list of DNA sequences sorted from those with 0% GC-content to those with 100% GC-content. The function sorts them primarily by GC-content in descending order. The final output is a list of sequences sorted in descending order of GC-content, which is the opposite of the desired order (ascending). Therefore, we need to reverse this logic to deduce the input that would result in the desired output.

### Plan
1. **Reverse the Sorting Logic**: Since the function sorts sequences by descending GC-content, we need to consider how the input could be structured so that when sorted in descending order, the sequences appear in ascending order of GC-content.
2. **Identify GC-content Calculation**: Understand how GC-content is calculated and how it influences sorting.
3. **Consider Edge Cases**: Explore sequences with extreme GC-content values (0% and 100%) and how they affect sorting.

### Execute
1. **Reverse the Sorting Logic**:
   - The function sorts sequences by `(-x[0], x[1])`, meaning it first sorts by GC-content in descending order. To achieve ascending order of GC-content, the input should be structured such that the descending sort results in the desired order.
2. **Identify GC-content Calculation**:
   - GC-content is `(seq.count('G') + seq.count('C')) / len(seq)`. Sequences with more 'G' and 'C' have higher GC-content.
3. **Deduce Input**:
   - To achieve the desired output, input sequences should be structured such that when sorted by descending GC-content, they naturally appear in ascending order.
   - Input: `['AAAA', 'AACG', 'ACGT', 'CGCG', 'GGGG']`
   - This input results in GC-content values of 0%, 50%, 50%, 100%, and 100%, respectively. When sorted by descending GC-content, the order is `['GGGG', 'CGCG', 'ACGT', 'AACG', 'AAAA']`, which is the reverse of the desired order.

### Reflect
The deduced input is structured to ensure that when sorted by descending GC-content, the sequences appear in ascending order of GC-content. This approach considers the function's sorting logic and the calculation of GC-content.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Input: Plausible input 1: ['AAAA', 'AACG', 'ACGT', 'CGCG', 'GGGG']
}}
\end{tcolorbox}



\clearpage
\onecolumn





% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Bi-Directional Conversation (Difficulty 4)}
\label{lst:bidirectional-hard-sample-newton} % You can still label and ref this subsection

% --- User Prompt Section (Forward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Forward)}
\vspace{2pt}

The `solve\_polynomial` function finds all real roots of a polynomial equation using Newton's method, handling polynomials up to degree 10, with mechanisms to estimate the derivative and manage non-convergence cases.
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
def solve_polynomial(coefficients: list[float]) -> list[float]:
    """
    Solves polynomial equations using a recursive implementation of Newton's method.
    """
    from math import isclose

    def evaluate_polynomial(coeffs, x):
        return sum(c * (x ** i) for i, c in enumerate(coeffs))

    def evaluate_derivative(coeffs, x):
        return sum(i * c * (x ** (i - 1)) for i, c in enumerate(coeffs) if i != 0)

    def newtons_method_recursive(coeffs, x, tolerance=1e-7, max_iterations=1000, iteration=0):
        if iteration >= max_iterations:
            return None
        f_x = evaluate_polynomial(coeffs, x)
        f_prime_x = evaluate_derivative(coeffs, x)
        if isclose(f_prime_x, 0, abs_tol=tolerance):
            return None
        next_x = x - f_x / f_prime_x
        if isclose(x, next_x, abs_tol=tolerance):
            return next_x
        return newtons_method_recursive(coeffs, next_x, tolerance, max_iterations, iteration + 1)

    degree = len(coefficients) - 1
    initial_guesses = [i * 0.5 for i in range(-degree, degree + 1)]

    roots = []
    for guess in initial_guesses:
        root = newtons_method_recursive(coefficients, guess)
        if root is not None and all(not isclose(root, r, abs_tol=1e-5) for r in roots):
            roots.append(root)

    return roots
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What does the `solve\_polynomial` function return when given the input `[1] + [0]*9 + [-1]`?
}}
\end{tcolorbox}

% --- Model Response Section (Forward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The `solve_polynomial` function is designed to find the roots of a polynomial equation using Newton's method. The input to the function is a list of coefficients representing a polynomial, where the index of each coefficient corresponds to the power of the variable (e.g., `[1, 0, 0, ..., -1]` represents \(x^{10} - 1\)). The function uses recursive Newton's method to approximate the roots and returns a list of unique roots found within a specified tolerance.

Key components of the function:
- **evaluate_polynomial**: Computes the value of the polynomial at a given point.
- **evaluate_derivative**: Computes the derivative of the polynomial at a given point.
- **newtons_method_recursive**: Implements Newton's method recursively to find a root starting from an initial guess.
- **initial_guesses**: A list of initial guesses for the roots, generated based on the degree of the polynomial.
- **roots**: A list that accumulates unique roots found during the iteration over initial guesses.

The function aims to find all distinct roots of the polynomial within a specified tolerance.

### Plan
To determine the output of the function for the input `[1] + [0]*9 + [-1]`, we will:
1. Identify the polynomial represented by the input coefficients.
2. Analyze the structure of the polynomial to predict its roots.
3. Understand how Newton's method is applied to find these roots.
4. Consider the initial guesses and how they influence the root-finding process.
5. Verify the uniqueness of the roots found using the `isclose` function.

### Execute
1. **Identify the Polynomial**:
   - The input `[1] + [0]*9 + [-1]` represents the polynomial \(x^{10} - 1\).
   - The roots of \(x^{10} - 1 = 0\) are the 10th roots of unity.
2. **Analyze the Roots**:
   - The 10th roots of unity are complex numbers given by \(e^{2\pi i k / 10}\) for \(k = 0, 1, 2, \ldots, 9\).
   - The real roots are \(x = 1\) and \(x = -1\).
3. **Newton's Method Application**:
   - Newton's method is used to approximate these roots starting from various initial guesses.
   - The initial guesses are generated as \([-5.0, -4.5, \ldots, 5.0]\).
4. **Root Finding Process**:
   - For each initial guess, Newton's method iteratively refines the guess to converge to a root.
   - The function checks if the found root is close to any already found root using `isclose` with a tolerance of \(1e-5\).
   - Only unique roots are added to the `roots` list.
5. **Verify Uniqueness**:
   - The function ensures that only distinct roots are returned by checking the proximity of each new root to the existing ones in the `roots` list.

### Reflect
The function correctly identifies the real roots of the polynomial \(x^{10} - 1\), which are \(x = 1\) and \(x = -1\). The use of Newton's method with a range of initial guesses ensures that these roots are found, and the `isclose` function ensures that only unique roots are returned. The output is consistent with the expected roots of the polynomial.

The reasoning process confirms that the function's logic and implementation are sound, and the final output aligns with the mathematical properties of the polynomial.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Output: [-1.0, 1.0]
}}
\end{tcolorbox}

% --- User Prompt Section (Backward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Backward)}
\vspace{2pt}\\
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What input would produce the output `[-1.0, 1.0]` when passed to the `solve\_polynomial` function?
}}
\end{tcolorbox}

% --- Model Response Section (Backward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine the input(s) for the `solve_polynomial` function that result in the output `[-1.0, 1.0]`. The function solves polynomial equations using Newton's method. It evaluates a polynomial and its derivative, then iteratively refines guesses for the roots. The polynomial is defined by its coefficients, and the function returns all unique roots found within a specified tolerance.

Key components:
- **evaluate_polynomial**: Computes the polynomial's value at a given point.
- **evaluate_derivative**: Computes the derivative's value at a given point.
- **newtons_method_recursive**: Applies Newton's method to find a root starting from an initial guess.
- **initial_guesses**: A range of guesses based on the polynomial's degree.
- **roots**: Stores unique roots found during the process.

### Plan
To deduce the input(s) that produce `[-1.0, 1.0]`, we need to reverse-engineer the polynomial whose roots are `-1.0` and `1.0`. This involves:
1. **Mathematical Analysis**: Identify the polynomial that has `-1.0` and `1.0` as roots.
2. **Verification**: Ensure the polynomial's degree and coefficients align with the function's logic.
3. **Exploration of Alternatives**: Consider other polynomials with the same roots to ensure all possibilities are covered.
4. **Validation**: Compare deduced inputs with the given input to confirm correctness.

### Execute
1. **Mathematical Analysis**:
   - A polynomial with roots `-1.0` and `1.0` can be expressed as \( (x + 1)(x - 1) = x^2 - 1 \).
   - This expands to the polynomial \( x^2 - 1 \), with coefficients `[1, 0, -1]`.
2. **Verification**:
   - The degree of the polynomial \( x^2 - 1 \) is 2, which matches the length of the coefficients list minus one.
   - The function uses initial guesses from `-degree` to `degree`, which for a degree 2 polynomial includes `-1, -0.5, 0, 0.5, 1`. This range should allow finding both roots.
3. **Exploration of Alternatives**:
   - Consider higher-degree polynomials with the same roots, such as \( (x + 1)^2(x - 1)^2 = x^4 - 2x^2 + 1 \).
   - This expands to the polynomial \( x^4 - 2x^2 + 1 \), with coefficients `[1, 0, -2, 0, 1]`.
4. **Validation**:
   - The given input `[1] + [0]*9 + [-1]` corresponds to \( x^{10} - 1 \), which also has roots `-1` and `1` among others. However, it includes additional roots not relevant to the output `[-1.0, 1.0]`.
   - The deduced inputs `[1, 0, -1]` and `[1, 0, -2, 0, 1]` are simpler and directly produce the desired output.

### Reflect
The deduced inputs `[1, 0, -1]` and `[1, 0, -2, 0, 1]` are both valid as they produce the output `[-1.0, 1.0]`. The simpler polynomial `[1, 0, -1]` is optimal due to its minimal degree. The given input `[1] + [0]*9 + [-1]` is a higher-degree polynomial that also includes `-1` and `1` as roots but is not minimal. The approach was exhaustive, considering both minimal and alternative polynomial forms.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Input: Plausible input 1: [1, 0, -1]
Plausible input 2: [1, 0, -2, 0, 1]
}}
\end{tcolorbox}


\clearpage
\onecolumn


% --- This is the new, non-floating caption/title ---
\subsection*{Appendix Sample: Bi-Directional Conversation (Difficulty 4)}
\label{lst:bidirectional-merge-intervals} % Unique label for this sample

% --- User Prompt Section (Forward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Forward)}
\vspace{2pt}

The `solution` function merges overlapping intervals from a list of tuples by sorting them and combining intervals that overlap or touch, ensuring the merged list is returned with a time complexity of O(n log n).
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]
def solution(intervals):
    # Sort intervals by start time
    intervals.sort(key=lambda x: x[0])
    
    # Initialize the list to store merged intervals
    merged_intervals = []
    
    # Unpack the first interval and add to merged_intervals
    first_start, first_end = intervals[0]
    merged_intervals.append((first_start, first_end))
    
    # Iterate over the remaining intervals
    for start, end in intervals[1:]:
        # Unpack the last interval in merged_intervals
        last_start, last_end = merged_intervals[-1]
        
        # Check for overlap
        if start <= last_end:
            # Merge intervals
            merged_intervals[-1] = (last_start, max(last_end, end))
        else:
            # No overlap, add the current interval
            merged_intervals.append((start, end))
    
    return merged_intervals
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
When I run the function `solution` with the input `[(1, 10), (2, 6), (8, 10), (15, 18)]`, will it return `[(1, 10), (15, 18)]` as expected?
}}
\end{tcolorbox}

% A natural paragraph break (a blank line in the code) allows for a page break.

% --- Model Response Section (Forward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine if the function `solution` correctly returns `[(1, 10), (15, 18)]` when given the input `[(1, 10), (2, 6), (8, 10), (15, 18)]`. The function is designed to merge overlapping intervals. It first sorts the intervals by their start times, then iteratively checks for overlaps, merging them if necessary, and finally returns the list of merged intervals. The key components influencing the reasoning are the sorting step, the loop that checks for overlaps, and the condition that determines whether intervals should be merged or added as separate intervals.

### Plan
1. **Initialization and Sorting**: Start by understanding how the input is sorted. This will affect the order in which intervals are processed.
2. **Merging Logic**: Analyze the loop that processes each interval to determine how overlaps are identified and merged.
3. **Edge Cases**: Consider edge cases such as intervals that do not overlap and intervals that are completely contained within others.
4. **Verification**: Ensure that the final list of intervals matches the expected output by following the logic step-by-step.

### Execute
1. **Initialization and Sorting**:
   - The input `[(1, 10), (2, 6), (8, 10), (15, 18)]` is sorted by the start time, resulting in the same order since the intervals are already sorted by their start times.
2. **Merging Logic**:
   - Initialize `merged_intervals` with the first interval `(1, 10)`.
   - Process the second interval `(2, 6)`:
     - Compare with the last interval in `merged_intervals`, `(1, 10)`.
     - Since `2 <= 10`, they overlap. Merge them into `(1, 10)`.
   - Process the third interval `(8, 10)`:
     - Compare with the last interval in `merged_intervals`, `(1, 10)`.
     - Since `8 <= 10`, they overlap. Merge them into `(1, 10)`.
   - Process the fourth interval `(15, 18)`:
     - Compare with the last interval in `merged_intervals`, `(1, 10)`.
     - Since `15 > 10`, they do not overlap. Add `(15, 18)` as a new interval.
3. **Edge Cases**:
   - The intervals `(2, 6)` and `(8, 10)` are fully contained within `(1, 10)`, which is correctly handled by the merging logic.
   - The interval `(15, 18)` does not overlap with any existing intervals, so it is added as a separate interval.
4. **Verification**:
   - The final list of merged intervals is `[(1, 10), (15, 18)]`, which matches the expected output.

### Reflect
The reasoning process confirms that the function correctly identifies and merges overlapping intervals, and correctly handles non-overlapping intervals. The expected output `[(1, 10), (15, 18)]` is indeed returned by the function when given the input `[(1, 10), (2, 6), (8, 10), (15, 18)]`. The approach considered both the merging logic and edge cases, ensuring a comprehensive understanding of the function's behavior. The answer is optimal and aligns with the function's intended purpose.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Output: [(1, 10), (15, 18)]
}}
\end{tcolorbox}

% --- User Prompt Section (Backward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white, 
    colframe=blue!20!white, % <-- Blue Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{blue!60!black}User Prompt (Backward)}
\vspace{2pt}\\
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What input would make the function `solution` return the output `[(1, 10), (15, 18)]`?
}}
\end{tcolorbox}

% --- Model Response Section (Backward) ---
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=ForestGreen!5!white, 
    colframe=ForestGreen!20!white, % <-- Green Frame
    boxrule=0.8pt, arc=3pt, boxsep=4pt
]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine what input to the function `solution` would result in the output `[(1, 10), (15, 18)]`. The function takes a list of intervals and merges overlapping intervals. The process involves sorting the intervals by their start times and then iterating through them to merge any overlapping intervals. The output `[(1, 10), (15, 18)]` suggests that there are two distinct, non-overlapping intervals in the final result. This implies that any intervals that could potentially merge into a single interval must either be non-overlapping or already merged in such a way that they result in the specified output.

### Plan
To deduce the input(s) that produce the output `[(1, 10), (15, 18)]`, we need to reverse-engineer the merging process:
1. **Identify Non-Overlapping Intervals**: The output consists of two intervals, `(1, 10)` and `(15, 18)`, which are non-overlapping. This means any input intervals that could merge into a single interval must be adjusted so they do not overlap.
2. **Consider Overlapping Scenarios**: Determine which input intervals could potentially overlap and how they must be structured to result in the given output after merging.
3. **Reverse the Merging Logic**: Work backwards from the output to infer possible inputs. This involves considering how intervals could be split or adjusted to avoid merging.
4. **Explore Multiple Configurations**: Consider different configurations of input intervals that could lead to the same output, ensuring all possibilities are covered.

### Execute
1. **Non-Overlapping Intervals**: The intervals `(1, 10)` and `(15, 18)` are already non-overlapping. Therefore, any input intervals that directly map to these without merging are valid. For example, `[(1, 10), (15, 18)]` itself is a valid input.
2. **Potential Overlaps**:
   - **Interval `(1, 10)`**: Any input intervals that could merge into `(1, 10)` must overlap or be contiguous within this range. Possible configurations include:
     - `[(1, 10)]` (no merging needed)
     - `[(1, 5), (5, 10)]` (overlapping and merge to `(1, 10)`)
     - `[(1, 9), (9, 10)]` (overlapping and merge to `(1, 10)`)
     - `[(1, 6), (6, 10)]` (overlapping and merge to `(1, 10)`)
     - `[(1, 8), (8, 10)]` (overlapping and merge to `(1, 10)`)
     - `[(1, 7), (7, 10)]` (overlapping and merge to `(1, 10)`)
     - `[(2, 10), (1, 3)]` (overlapping and merge to `(1, 10)`)
3. **Interval `(15, 18)`**: Similarly, any input intervals that could merge into `(15, 18)` must overlap or be contiguous within this range. Possible configurations include:
   - `[(15, 18)]` (no merging needed)
   - `[(15, 17), (17, 18)]` (overlapping and merge to `(15, 18)`)
   - `[(15, 16), (16, 18)]` (overlapping and merge to `(15, 18)`)
   - `[(15, 19), (15, 16)]` (overlapping and merge to `(15, 18)`)
4. **Combining Configurations**: Combine the configurations for `(1, 10)` and `(15, 18)` to form complete input sets:
   - `[(1, 10), (15, 18)]`
   - `[(1, 5), (5, 10), (15, 18)]`
   - `[(1, 9), (9, 10), (15, 18)]`
   - `[(1, 6), (6, 10), (15, 18)]`
   - `[(1, 8), (8, 10), (15, 18)]`
   - `[(1, 7), (7, 10), (15, 18)]`
   - `[(2, 10), (1, 3), (15, 18)]`
   - `[(1, 10), (15, 17), (17, 18)]`
   - `[(1, 10), (15, 16), (16, 18)]`
   - `[(1, 10), (15, 19), (15, 16)]`

### Reflect
The deduced inputs cover all possible configurations that could result in the output `[(1, 10), (15, 18)]`. Each configuration respects the merging logic of the function, ensuring that intervals either merge correctly or remain non-overlapping. The given input `[(1, 10), (2, 6), (8, 10), (15, 18)]` is one such configuration that results in the desired output, confirming the validity of the reasoning process. The approach was exhaustive, considering all potential overlaps and non-overlapping scenarios, ensuring no possible input was overlooked.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Input: Plausible input 1: [(1, 10), (15, 18)]
Plausible input 2: [(1, 5), (5, 10), (15, 18)]
Plausible input 3: [(1, 9), (9, 10), (15, 18)]
Plausible input 4: [(1, 6), (6, 10), (15, 18)]
Plausible input 5: [(1, 8), (8, 10), (15, 18)]
Plausible input 6: [(1, 7), (7, 10), (15, 18)]
Plausible input 7: [(2, 10), (1, 3), (15, 18)]
Plausible input 8: [(1, 10), (15, 17), (17, 18)]
Plausible input 9: [(1, 10), (15, 16), (16, 18)]
Plausible input 10: [(1, 10), (15, 19), (15, 16)]
}}
\end{tcolorbox}



\clearpage
\onecolumn

% --- Custom Color & Listings Definitions ---
% --- Colors for VS Code Theme Trace ---
\definecolor{TraceAction}{RGB}{86, 156, 214}
\definecolor{TraceVarState}{RGB}{212, 153, 63}
\definecolor{TraceTimestamp}{RGB}{128, 128, 128}
\definecolor{TracePyKeyword}{RGB}{86, 156, 214}
\definecolor{TracePyNumber}{RGB}{181, 206, 168}
\lstdefinestyle{python-custom}{...} % Your python style definition here


\lstdefinestyle{python-custom}{
    language=Python,
    basicstyle=\ttfamily\scriptsize,
    keywordstyle=\color{keywordblue},
    stringstyle=\color{stringred},
    commentstyle=\color{commentgreen},
    morecomment=[l]{\#},
    frame=tb, % Top and bottom frame lines
    framerule=0.5pt,
    numbers=none,
    breaklines=true,
    showstringspaces=false,
}




\subsection*{Appendix Sample: Mapping an Execution Trace to Bi-Directional CoT}
\label{lst:trace-to-cot-sample}

% --- This single tcolorbox contains all three parts ---
% \begin{tcolorbox}[
%     enhanced, breakable,
%     title={\textbf{1. Ground-Truth Execution Trace}},
%     colback=black!5!white, colframe=black!20!white,
%     boxrule=0.8pt, arc=3pt, boxsep=4pt,
%     fontupper=\ttfamily\scriptsize % Ensure font is correct
% ]
\begin{tcolorbox}[
    enhanced, breakable,
    title={\textbf{1. Ground-Truth Execution Trace}},
    colback=black,      % <-- CHANGED: Background is now black
    colframe=white,     % <-- CHANGED: Frame is now white
    coltext=white,      % <-- ADDED: Text color must be white to be visible
    colbacktitle=black,  
    boxrule=0.8pt, arc=3pt, boxsep=4pt,
    fontupper=\ttfamily\scriptsize
]
\setlength{\parindent}{0pt} % No indentation for these lines
\textcolor{TraceVarState}{Starting var:..} numbers = [-2, 3, -1, 0] \\
\textcolor{TraceVarState}{Starting var:..} num\_threads = 2 \\
\textcolor{TraceTimestamp}{19:03:21.790438} \textcolor{TraceAction}{call} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{6} \textcolor{TracePyKeyword}{def} parallel\_sort(numbers: list[int], num\_threads: int) -> list[int]: \\
\textcolor{TraceTimestamp}{19:03:21.792564} \textcolor{TraceAction}{line} \phantom{xxxxxxxxxx} \textcolor{TracePyNumber}{7} \phantom{xx} \textcolor{TracePyKeyword}{if not} numbers: \\
\textcolor{TraceTimestamp}{19:03:21.793392} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{11} \phantom{x} chunk\_size = len(numbers) // num\_threads \\
\textcolor{TraceVarState}{New var:.......} chunk\_size = 2 \\
\textcolor{TraceTimestamp}{19:03:21.793808} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{12} \phantom{x} chunks = [numbers[i:i + chunk\_size] \textcolor{TracePyKeyword}{for} i \textcolor{TracePyKeyword}{in} range(0, len(numbers), chunk\_size)] \\
\textcolor{TraceVarState}{New var:.......} i = 0 \\
\textcolor{TraceTimestamp}{19:03:21.794953} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{12} \phantom{x} chunks = [numbers[i:i + chunk\_size] \textcolor{TracePyKeyword}{for} i \textcolor{TracePyKeyword}{in} range(0, len(numbers), chunk\_size)] \\
\textcolor{TraceVarState}{Modified var:..} i = 2 \\
\textcolor{TraceTimestamp}{19:03:21.795618} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{12} \phantom{x} chunks = [numbers[i:i + chunk\_size] \textcolor{TracePyKeyword}{for} i \textcolor{TracePyKeyword}{in} range(0, len(numbers), chunk\_size)] \\
\textcolor{TraceVarState}{New var:.......} chunks = [[-2, 3], [-1, 0]] \\
\textcolor{TraceTimestamp}{19:03:21.796810} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{15} \phantom{x} threads = [] \\
\textcolor{TraceVarState}{New var:.......} threads = [] \\
\textcolor{TraceTimestamp}{19:03:21.798166} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{16} \phantom{x} sorted\_chunks = [None] * num\_threads \\
\textcolor{TraceVarState}{New var:.......} sorted\_chunks = [None, None] \\
\textcolor{TraceTimestamp}{19:03:21.798746} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{17} \phantom{x} lock = threading.Lock() \\
\textcolor{TraceVarState}{New var:.......} lock = <unlocked \_thread.lock object at 0x7fd060936f80> \\
\textcolor{TraceTimestamp}{19:03:21.799592} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{19} \phantom{x} \textcolor{TracePyKeyword}{def} sort\_chunk(index): \\
\textcolor{TraceVarState}{New var:.......} sort\_chunk = <function parallel\_sort.<locals>.sort\_chunk at 0x7fd0607187c0> \\
\textcolor{TraceTimestamp}{19:03:21.800026} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{24} \phantom{x} \textcolor{TracePyKeyword}{for} i \textcolor{TracePyKeyword}{in} range(num\_threads): \\
\textcolor{TraceVarState}{New var:.......} i = 0 \\
\textcolor{TraceTimestamp}{19:03:21.800171} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{25} \phantom{xx} thread = threading.Thread(target=sort\_chunk, args=(i,)) \\
\textcolor{TraceVarState}{New var:.......} thread = <Thread(Thread-1 (sort\_chunk), initial)> \\
\textcolor{TraceTimestamp}{19:03:21.800504} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{26} \phantom{xx} threads.append(thread) \\
\textcolor{TraceVarState}{Modified var:..} threads = [<Thread(Thread-1 (sort\_chunk), initial)>] \\
\textcolor{TraceTimestamp}{19:03:21.800979} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{27} \phantom{xx} thread.start() \\
\textcolor{TraceVarState}{Modified var:..} threads = [<Thread(Thread-1 (sort\_chunk), stopped \dots)>] \\
\textcolor{TraceVarState}{Modified var:..} thread = <Thread(Thread-1 (sort\_chunk), stopped \dots)> \\
\textcolor{TraceVarState}{Modified var:..} sorted\_chunks = [[-2, 3], None] \\
\textcolor{TraceTimestamp}{19:03:21.801718} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{24} \phantom{x} \textcolor{TracePyKeyword}{for} i \textcolor{TracePyKeyword}{in} range(num\_threads): \\
\textcolor{TraceVarState}{Modified var:..} i = 1 \\
\textcolor{TraceTimestamp}{19:03:21.802448} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{25} \phantom{xx} thread = threading.Thread(target=sort\_chunk, args=(i,)) \\
\textcolor{TraceVarState}{New var:.......} thread = <Thread(Thread-2 (sort\_chunk), initial)> \\
\textcolor{TraceTimestamp}{19:03:21.803108} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{26} \phantom{xx} threads.append(thread) \\
\textcolor{TraceVarState}{Modified var:..} threads = [<Thread(Thread-1 \dots)>, <Thread(Thread-2 \dots)>] \\
\textcolor{TraceTimestamp}{19:03:21.803716} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{27} \phantom{xx} thread.start() \\
\textcolor{TraceVarState}{Modified var:..} threads = [<Thread(Thread-1 \dots)>, <Thread(Thread-2 \dots, stopped)>] \\
\textcolor{TraceVarState}{Modified var:..} thread = <Thread(Thread-2 (sort\_chunk), stopped \dots)> \\
\textcolor{TraceVarState}{Modified var:..} sorted\_chunks = [[-2, 3], [-1, 0]] \\
\textcolor{TraceTimestamp}{19:03:21.804575} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{24} \phantom{x} \textcolor{TracePyKeyword}{for} i \textcolor{TracePyKeyword}{in} range(num\_threads): \\
\textcolor{TraceTimestamp}{19:03:21.804784} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{29} \phantom{x} \textcolor{TracePyKeyword}{for} thread \textcolor{TracePyKeyword}{in} threads: \\
\textcolor{TraceVarState}{Modified var:..} thread = <Thread(Thread-1 (sort\_chunk), stopped \dots)> \\
\textcolor{TraceTimestamp}{19:03:21.804976} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{30} \phantom{xx} thread.join() \\
\textcolor{TraceTimestamp}{19:03:21.805077} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{29} \phantom{x} \textcolor{TracePyKeyword}{for} thread \textcolor{TracePyKeyword}{in} threads: \\
\textcolor{TraceVarState}{Modified var:..} thread = <Thread(Thread-2 (sort\_chunk), stopped \dots)> \\
\textcolor{TraceTimestamp}{19:03:21.805149} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{30} \phantom{xx} thread.join() \\
\textcolor{TraceTimestamp}{19:03:21.805245} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{29} \phantom{x} \textcolor{TracePyKeyword}{for} thread \textcolor{TracePyKeyword}{in} threads: \\
\textcolor{TraceTimestamp}{19:03:21.805299} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{33} \phantom{x} merged\_list = [] \\
\textcolor{TraceVarState}{New var:.......} merged\_list = [] \\
\textcolor{TraceTimestamp}{19:03:21.805354} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{34} \phantom{x} \textcolor{TracePyKeyword}{for} chunk \textcolor{TracePyKeyword}{in} sorted\_chunks: \\
\textcolor{TraceVarState}{New var:.......} chunk = [-2, 3] \\
\textcolor{TraceTimestamp}{19:03:21.807452} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{35} \phantom{xx} \textcolor{TracePyKeyword}{if} chunk: \\
\textcolor{TraceTimestamp}{19:03:21.807554} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{36} \phantom{xxx} merged\_list.extend(chunk) \\
\textcolor{TraceVarState}{Modified var:..} merged\_list = [-2, 3] \\
\textcolor{TraceTimestamp}{19:03:21.807622} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{34} \phantom{x} \textcolor{TracePyKeyword}{for} chunk \textcolor{TracePyKeyword}{in} sorted\_chunks: \\
\textcolor{TraceVarState}{Modified var:..} chunk = [-1, 0] \\
\textcolor{TraceTimestamp}{19:03:21.807701} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{35} \phantom{xx} \textcolor{TracePyKeyword}{if} chunk: \\
\textcolor{TraceTimestamp}{19:03:21.807792} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{36} \phantom{xxx} merged\_list.extend(chunk) \\
\textcolor{TraceVarState}{Modified var:..} merged\_list = [-2, 3, -1, 0] \\
\textcolor{TraceTimestamp}{19:03:21.807846} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{34} \phantom{x} \textcolor{TracePyKeyword}{for} chunk \textcolor{TracePyKeyword}{in} sorted\_chunks: \\
\textcolor{TraceTimestamp}{19:03:21.807932} \textcolor{TraceAction}{line} \phantom{xxxxxxxxx} \textcolor{TracePyNumber}{38} \phantom{x} \textcolor{TracePyKeyword}{return} sorted(merged\_list) \\
\textcolor{TraceTimestamp}{19:03:21.807997} \textcolor{TraceAction}{return} \phantom{xxxxx} \textcolor{TracePyNumber}{38} \phantom{x} \textcolor{TracePyKeyword}{return} sorted(merged\_list) \\
\textcolor{TraceVarState}{Return value:..} [-2, -1, 0, 3] \\
\textcolor{TraceTimestamp}{Elapsed time: 00:00:00.017813}
\end{tcolorbox}

% --- Part 2: Forward Reasoning from the Trace ---
\vspace{4pt}
\textbf{\\2. Forward Reasoning constructed from Execution-Trace}
\begin{tcolorbox}[enhanced, breakable, colback=blue!5!white, colframe=blue!20!white, boxrule=0.8pt, arc=3pt, boxsep=4pt]
\textbf{\color{blue!60!black}User Prompt (Forward)}
\vspace{2pt}

The `parallel\_sort` function sorts a list of numbers by dividing it into chunks, sorting each chunk in a separate thread, and then merging the sorted chunks into a single sorted list using a lock to ensure thread-safe operations.
\vspace{2pt}

Here's the code:
\begin{lstlisting}[style=python-custom]

import threading

def parallel_sort(numbers: list[int], num_threads: int) -> list[int]:
    if not numbers:
        return []

    # Divide the list into chunks
    chunk_size = len(numbers) // num_threads
    chunks = [numbers[i:i + chunk_size] for i in range(0, len(numbers), chunk_size)]

    # Sort each chunk in a separate thread
    threads = []
    sorted_chunks = [None] * num_threads
    lock = threading.Lock()

    def sort_chunk(index):
        sorted_chunks[index] = sorted(chunks[index])
        with lock:
            print(f"Chunk {index} sorted: {sorted_chunks[index]}")

    for i in range(num_threads):
        thread = threading.Thread(target=sort_chunk, args=(i,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    # Merge the sorted chunks
    merged_list = []
    for chunk in sorted_chunks:
        if chunk:
            merged_list.extend(chunk)

    return sorted(merged_list)
\end{lstlisting}
% --- Highlighted Question ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What output does the `parallel\_sort` function return when given the input `[-2, 3, -1, 0]` with 2 threads?
}}
\end{tcolorbox}
\begin{tcolorbox}[enhanced, breakable, colback=ForestGreen!5!white, colframe=ForestGreen!20!white, boxrule=0.8pt, arc=3pt, boxsep=4pt]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine the output of the `parallel_sort` function when given the input `[-2, 3, -1, 0]` with 2 threads. The function is designed to sort a list of numbers using parallel processing by dividing the list into chunks, sorting each chunk in a separate thread, and then merging the sorted chunks into a final sorted list.

Key components of the function include:
- **Chunk Division**: The list is divided into chunks based on the number of threads.
- **Threaded Sorting**: Each chunk is sorted in a separate thread.
- **Merging**: The sorted chunks are merged and the final list is sorted before returning.

### Plan
1. **Chunk Division**: Calculate the size of each chunk and divide the list accordingly.
2. **Threaded Sorting**: Understand how each chunk is sorted in parallel.
3. **Merging**: Combine the sorted chunks and sort the final list.
4. **Verification**: Ensure the final sorted list is correct.

### Execute
1. **Chunk Division**:
   - The input list is `[-2, 3, -1, 0]` and the number of threads is `2`.
   - Calculate `chunk_size = len(numbers) // num_threads = 4 // 2 = 2`.
   - Divide the list into chunks: `chunks = [[-2, 3], [-1, 0]]`.

2. **Threaded Sorting**:
   - Each chunk is sorted in a separate thread:
     - Thread 1 sorts `[-2, 3]` resulting in `[-2, 3]`.
     - Thread 2 sorts `[-1, 0]` resulting in `[-1, 0]`.
   - The sorted chunks are stored in `sorted_chunks = [[-2, 3], [-1, 0]]`.

3. **Merging**:
   - Initialize `merged_list = []`.
   - Extend `merged_list` with each sorted chunk:
     - After adding `[-2, 3]`, `merged_list = [-2, 3]`.
     - After adding `[-1, 0]`, `merged_list = [-2, 3, -1, 0]`.
   - Sort the merged list: `sorted(merged_list) = [-2, -1, 0, 3]`.

4. **Verification**:
   - The final sorted list `[-2, -1, 0, 3]` is consistent with the expected behavior of sorting the entire list.

### Reflect
The reasoning process involved understanding how the list is divided, sorted in parallel, and merged. The final step of sorting the merged list ensures the entire list is sorted correctly. The approach was thorough, considering each step of the function's logic. The final output aligns with the expected result, confirming the correctness of the reasoning.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Output: [-2, -1, 0, 3]
}}
\end{tcolorbox}

% --- Part 3: Backward Reasoning from the Trace ---
\vspace{4pt}
\textbf{3. Backward Reasoning constructed from Execution-Trace}
\begin{tcolorbox}[enhanced, breakable, colback=blue!5!white, colframe=blue!20!white, boxrule=0.8pt, arc=3pt, boxsep=4pt]
\textbf{\color{blue!60!black}User Prompt (Backward)}\\
\vspace{2pt}
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
What input would produce the output `[-2, -1, 0, 3]` when using the `parallel\_sort` function?
}}
\end{tcolorbox}
\begin{tcolorbox}[enhanced, breakable, colback=ForestGreen!5!white, colframe=ForestGreen!20!white, boxrule=0.8pt, arc=3pt, boxsep=4pt]
\textbf{\color{ForestGreen!60!black}Assistant Response }
\begin{lstlisting}[frame=none, numbers=none, basicstyle={\ttfamily\scriptsize}, breaklines=true]
### Understand
The goal is to determine the input(s) that would produce the output `[-2, -1, 0, 3]` when using the `parallel_sort` function. The function takes a list of integers and a number of threads as input. It divides the list into chunks, sorts each chunk in parallel using threads, merges the sorted chunks, and returns the fully sorted list. Key operations include list division, parallel sorting, and merging.

### Plan
To deduce the input(s), we need to reverse the operations performed by the function:
1. **Reverse the Final Sort**: The output is already sorted, so the merged list before the final sort must be `[-2, -1, 0, 3]`.
2. **Reverse the Merge**: Determine possible sorted chunks that, when merged, result in `[-2, -1, 0, 3]`.
3. **Reverse the Chunk Sorting**: Identify possible original chunks before sorting that could result in the sorted chunks.
4. **Reverse the Chunk Division**: Determine the original list that could be divided into the identified chunks.
5. **Consider Multiple Threads**: Explore different numbers of threads to see how they affect chunk sizes and division.

### Execute
1. **Reverse the Final Sort**: The list before the final sort is `[-2, -1, 0, 3]`.
2. **Reverse the Merge**:
   - Possible sorted chunks that merge to `[-2, -1, 0, 3]` include:
     - `[-2]` and `[-1, 0, 3]`
     - `[-2, -1]` and `[0, 3]`
     - `[-2, -1, 0]` and `[3]`
     - `[-2, -1, 0, 3]` (single chunk)
3. **Reverse the Chunk Sorting**:
   - For `[-2]` and `[-1, 0, 3]`, possible original chunks could be `[-2]` and `[-1, 3, 0]`.
   - For `[-2, -1]` and `[0, 3]`, possible original chunks could be `[-2, -1]` and `[3, 0]`.
4. **Reverse the Chunk Division**:
   - Consider different numbers of threads:
     - **2 Threads**: 
       - Possible original lists: `[-2, -1, 3, 0]`, `[-2, 3, -1, 0]`, `[-2, -1, 0, 3]`
     - **1 Thread**:
       - Possible original list: `[-2, -1, 0, 3]`
5. **Verify and Explore Alternatives**:
   - Check if other numbers of threads (e.g., 3 or 4) could yield different valid inputs.

### Reflect
The deduced inputs are consistent with the function's logic and the given output. The function's behavior with different numbers of threads and chunk divisions has been thoroughly explored. The inputs `[-2, -1, 3, 0]`, `[-2, 3, -1, 0]`, and `[-2, -1, 0, 3]` with 2 threads are valid, as are `[-2, -1, 0, 3]` with 1 thread, and variations with 3 or 4 threads. These inputs align with the given input `[-2, 3, -1, 0]` with 2 threads, confirming the correctness of the reasoning.
\end{lstlisting}
% --- Highlighted Predicted Output ---
\colorbox{highlightyellow}{\parbox{\dimexpr\linewidth-2\fboxsep}{\ttfamily\scriptsize
Predicted Input: Plausible input 1: [-2, -1, 3, 0], 2
Plausible input 2: [-2, 3, -1, 0], 2
Plausible input 3: [-2, -1, 0, 3], 1
Plausible input 4: [-2, -1, 0, 3], 3
Plausible input 5: [-2, 3, -1, 0], 3
Plausible input 6: [-2, -1, 0, 3], 4
}}
\end{tcolorbox}
% \end{tcolorbox}




\clearpage
\section*{Experimental Setup}
\subsubsection*{Compute Infrastructure}
We perform our experiments on a GPU cluster consisting of Dell XE9680 nodes. Each node has 96 CPU cores with 2 TB of system RAM. Each node is equipped with 8 Nvidia H100 GPUs, each having 80GB of GPU RAM. RHEL 9.4 is installed on the nodes. Each SFT run in our experiments uses 2 nodes (16 GPUs). Evaluation benchmarks are run on a single node using 8 GPUs.



\subsubsection*{SFT Setup}
We use Open Instruct Framework (\url{https://github.com/allenai/open-instruct}) for performing SFT. The hyper-parameters used for the training using 16 GPUs are described in table~\ref{tab-hyperparam}.

\begin{table*}[h!]
  \centering
  \begin{tabular}{|c|c|}
  \hline
    Batch Size & 32 \\
    Per Device Batch Size & 1 \\    
    Learning Rate & 2e-6 \\
    LR Scheduler & Linear \\
    Epochs & 10 \\
    Context Length & 8K \\
    \hline
  \end{tabular}
  \caption{SFT Hyper-parameters}
  \label{tab-hyperparam}
\end{table*}





\section*{Evaluation Setup}
Our evaluation is conducted using two established, public benchmarks designed to test code reasoning and execution prediction capabilities. We provide direct links to the official benchmark pipelines to ensure full reproducibility of our results. For a fair and transparent comparison across all models, we use the default inference parameters provided by the CruxEval and LiveCodeBench evaluation harnesses without any model-specific tuning.

\begin{itemize}[nosep, leftmargin=*]
    \item \textbf{CruxEval:} A benchmark for code reasoning via input/output prediction. The official repository and data can be found at: \url{https://github.com/google-deepmind/cruxeval}
    
    \item \textbf{LiveCodeBench:} A benchmark featuring problems from live programming contests that tests code execution. The official repository is available at: \url{https://github.com/livecodebench/livecodebench}
\end{itemize}

\section*{Data Generation Prompts}
This section provides the complete set of prompts used in our data synthesis pipeline. These prompts are referenced in Section 3 (Data Synthesis Pipeline) and are used throughout the hierarchical generation process in Stage A. The prompts are organized by their function in the pipeline, from concept generation through solution and test case synthesis.

\subsection*{Concept Generation Prompt}
This prompt is used to extract programming concepts from source documents as described in Section 3.1.

\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\scriptsize,
    colback=blue!5!white,
    colframe=blue!20!white,
    boxrule=0.8pt, arc=3pt, boxsep=4pt,
    title={\textbf{Concept Extraction Prompt}}, coltitle=black
]
You are a helpful assistant who is an expert in Python programming. Given a text chunk from technical documentation, identify key programming concepts that could inspire complex algorithmic problems. For each concept, provide:
- Concept: The name of the concept
- Description: A brief explanation
- Examples: Specific instances or use cases

Format each concept as:
'Concept': 'concept\_name', 'Description': 'description\_text', 'Examples': ['example1', 'example2', ...]

\textbf{Input:} \{chunk\}
\end{tcolorbox}

\subsection*{Instruction Generation Prompt}
This prompt generates diverse programming instructions for each concept, as described in Section 3.1.

\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\tiny,
    colback=blue!5!white,
    colframe=blue!20!white,
    boxrule=0.8pt, arc=3pt, boxsep=4pt,
    title={\textbf{Instruction Synthesis Prompt}}, coltitle=black
]
\begin{lstlisting}[basicstyle=\ttfamily\tiny,breaklines=true]
You are an expert in Python programming and instructional design. Given the concepts and examples below, generate six distinct instructions with complexity level: {difficulty}. Ensure the tasks are as non-overlapping as possible while covering diverse aspects of the concepts.

COMPLEXITY GUIDELINES:
1. This {difficulty} difficulty should create {complexity_description}.
2. Solutions should span approximately {expected_lines} of code with rich, intricate logic maximized for 'hard' tasks.

INSTRUCTIONS FOR PROBLEM DIVERSITY:
1. Create problems that are fundamentally different in:
   - Problem domain: Include mathematics (e.g., algebra for equations and transformations, timing & durations for scheduling or sequencing, probabilities for statistical analysis, geometry for spatial computations), finance, data processing, algorithms, text processing, or system design.
   - Computational approach: Vary between iterative, recursive, dynamic programming, functional, or object-oriented programming.
   - Algorithmic complexity: Target specific time complexities (e.g., O(n) for easy, O(n log n) for medium, O(n^2) or higher for hard).

Concept: {concept}
Description: {description}
Examples: {examples}

Generate your response in the following format:
Instruction1:
{}
Instruction2:
{}
...
\end{lstlisting}
\end{tcolorbox}

\subsection*{Signature Generation Prompt}
This prompt analyzes instructions and generates appropriate function or class signatures, as described in Section 3.1.

\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\tiny,
    colback=blue!5!white,
    colframe=blue!20!white,
    boxrule=0.8pt, arc=3pt, boxsep=4pt,
    title={\textbf{Signature Extraction Prompt}}, coltitle=black
]
\begin{lstlisting}[basicstyle=\ttfamily\tiny,breaklines=true]
You are a Python programming expert. Given the instruction below, analyze how it should be implemented and provide the best signature skeleton.

RULES:
1. Decide if the instruction requires a standalone function or a class
2. For a FUNCTION: Format as 'Function: name(param1: type1, param2: type2) -> return_type'
3. For a CLASS: Format as 'Class: ClassName; __init__(self, param1: type1) -> return_type; method1(self, param2: type2) -> return_type; ...'
4. Use ONLY spaces (no tabs, newlines, or escaped characters)

Instruction: {instruction}

Return the signature skeleton INSIDE a code block:
```text
Function: solution(input1: type1, input2: type2) -> return_type
```
or
```text
Class: ClassName; __init__(self, param1: type1) -> return_type; method1(self, param2: type2) -> return_type
```
\end{lstlisting}
\end{tcolorbox}

\subsection*{Code Generation Prompts}
These prompts generate multiple candidate solutions for each instruction. We use separate prompts for function-based and class-based solutions.

\subsubsection*{Function Code Generation}
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\tiny,
    colback=ForestGreen!5!white,
    colframe=ForestGreen!20!white,
    boxrule=0.8pt, arc=3pt, boxsep=4pt,
    title={\textbf{Function Solution Generation Prompt}}, coltitle=black
]
\begin{lstlisting}[basicstyle=\ttfamily\tiny,breaklines=true]
You are a Python programming expert. Generate 5 functionally correct Python code implementations adhering to these constraints:

1. Implement a standalone function with name '{function_name}', inputs '{input_params}', and return type '{return_type}' EXACTLY as provided.
2. Write all logic directly within the function.
3. The function MUST ALWAYS RETURN A VALUE matching the return type.
4. Ensure the code is fully modular and self-contained.
5. For hard difficulty, ensure solutions span approximately 50-100+ lines with complex algorithms and data structures.
6. Generate EXACTLY FIVE distinct implementations varying by:
   - Computational approach (iterative, recursive, dynamic programming, etc.)
   - Style and complexity
   - Variable names

Instruction: {instruction}
Signature: {function_name}({input_params}) -> {return_type}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{Class Code Generation}
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\tiny,
    colback=ForestGreen!5!white,
    colframe=ForestGreen!20!white,
    boxrule=0.8pt, arc=3pt, boxsep=4pt,
    title={\textbf{Class Solution Generation Prompt}}, coltitle=black
]
\begin{lstlisting}[basicstyle=\ttfamily\tiny,breaklines=true]
Generate 5 functionally correct Python class implementations with:
- Class name: {class_name}
- Constructor: {constructor_signature}
- Methods: {method_signatures}

Each method must be self-contained and return a value matching its specified return type.
Generate EXACTLY FIVE distinct implementations varying approaches, styles, and complexity.
\end{lstlisting}
\end{tcolorbox}

\subsection*{Test Generation Prompts}
These prompts generate comprehensive unit test suites for validating the candidate solutions.

\subsubsection*{Test Scenario Identification}
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\tiny,
    colback=orange!5!white,
    colframe=orange!20!white,
    boxrule=0.8pt, arc=3pt, boxsep=4pt,
    title={\textbf{Test Scenario Identification Prompt}}, coltitle=black
]
\begin{lstlisting}[basicstyle=\ttfamily\tiny,breaklines=true]
You are an expert in Python testing. Given the instruction and signature details, identify up to 10 concise test scenarios to ensure comprehensive coverage.

Focus on:
- Basic functionality of each method/function
- Key behaviors from the instruction
- Broad coverage including edge cases

Return in this format:
```text
Test scenario 1
Test scenario 2
...
```

Task: {instruction}
Signature: {signature_details}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{Function Test Generation}
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\tiny,
    colback=orange!5!white,
    colframe=orange!20!white,
    boxrule=0.8pt, arc=3pt, boxsep=4pt,
    title={\textbf{Function Test Generation Prompt}}, coltitle=black
]
\begin{lstlisting}[basicstyle=\ttfamily\tiny,breaklines=true]
Generate up to 10 isolated test cases following these CRITICAL GUIDELINES:

1. Each test must be a standalone function (def test_...():)
2. Each test function contains EXACTLY ONE assert statement
3. Every assert MUST DIRECTLY call the function with specific inputs:
   assert {function_name}(...) == expected_value
4. Do NOT use variables outside the assert
5. Generate tests corresponding to the required scenarios below

Task: {instruction}
Function Signature: {function_signature}
Required Test Scenarios: {required_tests}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{Class Test Generation}
\begin{tcolorbox}[
    enhanced, breakable,
    fontupper=\ttfamily\tiny,
    colback=orange!5!white,
    colframe=orange!20!white,
    boxrule=0.8pt, arc=3pt, boxsep=4pt,
    title={\textbf{Class Test Generation Prompt}}, coltitle=black
]
\begin{lstlisting}[basicstyle=\ttfamily\tiny,breaklines=true]
Generate up to 10 isolated test cases for class {class_name} with primary method {primary_method}.

Guidelines:
1. Each test is a standalone function
2. Each test contains EXACTLY ONE assert (unless multiple logically connected method calls are needed)
3. Directly call methods in asserts: assert {class_name}().{primary_method}(...) == expected_value
4. For connected methods, chain them: assert {class_name}().method1(...).method2(...) == expected_value

Class: {class_name}
Methods: {method_signatures}
Primary Method: {primary_method}
Required Scenarios: {required_tests}
\end{lstlisting}
\end{tcolorbox}

All custom analysis and evaluation scripts used to generate the results and figures presented in this paper, beyond the benchmark pipelines themselves, are included as part of the supplementary material.


